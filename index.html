<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Signal Test v17</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #000; color: #fff; min-height: 100vh; padding: 0.75rem; font-size: 12px; }
        .container { max-width: 580px; margin: 0 auto; border: 1px solid #fff; padding: 1rem; }
        h1 { font-size: 0.9rem; font-weight: normal; text-transform: uppercase; letter-spacing: 0.15em; margin-bottom: 0.75rem; text-align: center; border-bottom: 1px solid #333; padding-bottom: 0.4rem; }
        .section { margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #333; }
        .section.tx { border-color: #0a0; }
        .section.rx { border-color: #0aa; }
        .section.peak { border-color: #a0a; }
        .section.tx-pkt { border-color: #0a0; background: rgba(0,50,0,0.15); }
        .section.rx-pkt { border-color: #0aa; background: rgba(0,50,50,0.15); }
        .section-title { font-size: 0.6rem; color: #666; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.3rem; display: flex; justify-content: space-between; align-items: center; }
        .section.tx .section-title, .section.tx-pkt .section-title { color: #0f0; }
        .section.rx .section-title, .section.rx-pkt .section-title { color: #0ff; }
        .section.peak .section-title { color: #f0f; }
        .row { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.25rem; font-size: 0.65rem; flex-wrap: wrap; }
        .row:last-child { margin-bottom: 0; }
        .row label { color: #888; min-width: 50px; flex-shrink: 0; }
        input[type="range"] { flex: 1; height: 4px; -webkit-appearance: none; background: #333; outline: none; min-width: 60px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #fff; cursor: pointer; border-radius: 50%; }
        .section.tx input[type="range"]::-webkit-slider-thumb { background: #0f0; }
        .section.rx input[type="range"]::-webkit-slider-thumb { background: #0ff; }
        input[type="number"], input[type="text"] { background: #111; border: 1px solid #444; color: #fff; padding: 0.2rem 0.25rem; font-family: inherit; font-size: 0.65rem; text-align: center; }
        input[type="number"] { width: 50px; }
        input[type="text"].binary-input { width: 72px; font-family: inherit; letter-spacing: 1px; }
        input[type="number"]:focus, input[type="text"]:focus { outline: none; border-color: #fff; }
        .hz { font-size: 0.55rem; color: #666; }
        .range-display { font-size: 0.55rem; color: #666; margin-left: auto; }
        .section.tx .range-display, .section.tx-pkt .range-display { color: #0a0; }
        .section.rx .range-display, .section.rx-pkt .range-display { color: #0aa; }
        .binary-row { display: flex; align-items: center; gap: 0.25rem; margin-top: 0.4rem; padding-top: 0.4rem; border-top: 1px solid #222; }
        .binary-label { font-size: 0.55rem; color: #666; min-width: 40px; }
        .section.tx .binary-label { color: #0a0; }
        .section.rx .binary-label { color: #0aa; }
        .toggle-group { display: flex; gap: 1px; }
        .bit-toggle { width: 24px; height: 26px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #111; border: 1px solid #333; border-radius: 2px; cursor: pointer; transition: all 0.15s; position: relative; }
        .bit-toggle:hover { border-color: #555; }
        .bit-toggle.on { background: #0a0; border-color: #0f0; }
        .section.rx .bit-toggle.on { background: #088; border-color: #0ff; }
        .bit-toggle .bit-num { font-size: 0.45rem; color: #555; position: absolute; top: 1px; }
        .bit-toggle.on .bit-num { color: #000; }
        .bit-toggle .bit-val { font-size: 0.7rem; font-weight: bold; color: #444; }
        .bit-toggle.on .bit-val { color: #000; }
        .binary-string { font-size: 0.6rem; color: #555; font-family: inherit; letter-spacing: 0.05em; margin-left: auto; }
        .section.tx .binary-string { color: #0a0; }
        .section.rx .binary-string { color: #0aa; }
        .ascii-char { font-size: 0.65rem; font-weight: bold; margin-left: 0.2rem; padding: 0.1rem 0.25rem; background: #1a1a1a; border-radius: 2px; }
        .section.tx .ascii-char { color: #0f0; border: 1px solid #0a0; }
        .section.rx .ascii-char { color: #0ff; border: 1px solid #0aa; }
        .air-toggle { display: flex; justify-content: center; align-items: center; gap: 0.4rem; margin: 0.75rem 0; flex-wrap: wrap; }
        .air-btn { padding: 0.4rem 1.2rem; font-family: inherit; font-size: 0.7rem; font-weight: bold; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; border: 2px solid #444; background: #111; color: #666; border-radius: 4px; transition: all 0.2s; }
        .air-btn:hover { border-color: #666; }
        .air-btn.on { background: #f00; color: #fff; border-color: #f00; box-shadow: 0 0 15px rgba(255, 0, 0, 0.5); animation: air-pulse 1.5s infinite; }
        @keyframes air-pulse { 0%, 100% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.5); } 50% { box-shadow: 0 0 25px rgba(255, 0, 0, 0.8); } }
        .pulse-group { display: flex; align-items: center; gap: 0.25rem; }
        .pulse-btn { padding: 0.4rem 0.6rem; font-family: inherit; font-size: 0.7rem; font-weight: bold; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; border: 2px solid #0a0; background: #111; color: #0f0; border-radius: 4px; transition: all 0.1s; }
        .pulse-btn:hover { background: #0a0; color: #000; }
        .pulse-btn:active { background: #0f0; }
        .pulse-btn:disabled { border-color: #333; color: #333; cursor: not-allowed; }
        .pulse-btn:disabled:hover { background: #111; color: #333; }
        .packet-btn { border-color: #080; color: #0f0; }
        .packet-btn:hover { background: #080; color: #000; }
        .pulse-input { width: 42px; background: #111; border: 1px solid #0a0; color: #0f0; padding: 0.3rem 0.2rem; font-family: inherit; font-size: 0.6rem; text-align: center; border-radius: 3px; }
        .pulse-input:focus { outline: none; border-color: #0f0; }
        .pulse-label { font-size: 0.5rem; color: #0a0; }
        .graph-section { margin-bottom: 0.5rem; }
        .graph-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem; gap: 0.4rem; flex-wrap: wrap; }
        .graph-title { font-size: 0.55rem; color: #666; text-transform: uppercase; }
        .graph-controls { display: flex; align-items: center; gap: 0.15rem; flex-wrap: wrap; }
        .zoom-btn { width: 18px; height: 18px; font-family: inherit; font-size: 0.75rem; font-weight: bold; background: #111; color: #888; border: 1px solid #444; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 1; }
        .zoom-btn:hover { background: #222; color: #fff; border-color: #666; }
        .zoom-toggle { padding: 0.1rem 0.3rem; font-family: inherit; font-size: 0.5rem; font-weight: bold; background: #111; color: #555; border: 1px solid #333; border-radius: 3px; cursor: pointer; text-transform: uppercase; }
        .zoom-toggle:hover { border-color: #555; color: #888; }
        .zoom-toggle.tx-on { background: #0a0; color: #000; border-color: #0f0; }
        .zoom-toggle.rx-on { background: #088; color: #000; border-color: #0ff; }
        .zoom-input { width: 40px; background: #111; border: 1px solid #333; color: #888; padding: 0.15rem; font-family: inherit; font-size: 0.5rem; text-align: center; border-radius: 2px; }
        .zoom-input:focus { outline: none; border-color: #666; color: #fff; }
        .zoom-sep { color: #333; font-size: 0.45rem; }
        .graph-container { border: 1px solid #222; background: #050505; position: relative; overflow: hidden; }
        #graph { width: 100%; height: 100px; display: block; }
        .detection-info { text-align: center; font-size: 0.5rem; color: #555; min-height: 1.8em; padding: 0.2rem 0; line-height: 1.3; }
        .status-row { display: flex; gap: 0.4rem; margin-bottom: 0.4rem; }
        .status-box { flex: 1; text-align: center; font-size: 0.6rem; padding: 0.25rem; border: 1px solid #333; background: #0a0a0a; }
        .status-box.tx-status { border-color: #0a0; }
        .status-box.rx-status { border-color: #0aa; }
        .status-box.pkt-status { border-color: #a50; }
        .status-box .label { font-size: 0.45rem; color: #666; text-transform: uppercase; }
        .status-box.tx-status .label { color: #0a0; }
        .status-box.rx-status .label { color: #0aa; }
        .status-box.pkt-status .label { color: #a50; }
        .status-box .pattern { font-weight: bold; color: #888; font-size: 0.55rem; }
        .status-box.tx-status .pattern { color: #0f0; }
        .status-box.rx-status .pattern { color: #0ff; }
        .status-box.pkt-status .pattern { color: #fa0; }
        .status-box.match { background: #001a00; }
        .status-box.active { background: #0a0a00; }
        .status-box.pkt-ok { background: #1a0a00; }
        .log-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem; }
        .log-title { font-size: 0.55rem; color: #666; text-transform: uppercase; }
        .log-stats { font-size: 0.45rem; color: #555; display: flex; gap: 0.4rem; }
        .log-panel { height: 80px; overflow-y: auto; background: #050505; padding: 0.3rem; font-size: 0.5rem; border: 1px solid #222; margin-bottom: 0.5rem; }
        .log-entry { margin-bottom: 0.15rem; color: #555; display: flex; gap: 0.25rem; align-items: flex-start; }
        .log-entry .ts { color: #333; min-width: 65px; flex-shrink: 0; }
        .log-entry .tag { font-weight: bold; min-width: 26px; flex-shrink: 0; }
        .log-entry .msg { flex: 1; word-break: break-all; }
        .log-entry.rx .tag { color: #0ff; }
        .log-entry.rx .msg { color: #0aa; }
        .log-entry.tx .tag { color: #0f0; }
        .log-entry.tx .msg { color: #0a0; }
        .log-entry.pkt .tag { color: #fa0; }
        .log-entry.pkt .msg { color: #a80; }
        .log-entry.match .tag { color: #ff0; }
        .log-entry.match .msg { color: #ff0; font-weight: bold; }
        .log-entry.info .tag { color: #888; }
        .log-entry.info .msg { color: #666; }
        .log-entry.err .tag { color: #f00; }
        .log-entry.err .msg { color: #f00; }
        .timer { text-align: center; font-size: 1.1rem; font-weight: bold; margin: 0.2rem 0; }
        .timer.active { animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.4; } }
        .button-row { display: flex; gap: 0.4rem; }
        button.main-btn { flex: 1; padding: 0.5rem; font-family: inherit; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; border: none; transition: all 0.15s; }
        .btn-init { background: #fff; color: #000; }
        .btn-test { background: #0f0; color: #000; }
        .btn-reset { background: transparent; color: #fff; border: 1px solid #555 !important; }
        button.main-btn:disabled { background: #333; color: #666; cursor: not-allowed; }
        button.main-btn:hover:not(:disabled) { opacity: 0.8; }
        .progress { height: 2px; background: #222; margin-top: 0.5rem; }
        .progress-fill { height: 100%; background: #0f0; width: 0%; transition: width 0.1s; }
        .stepper { display: flex; align-items: center; gap: 0.1rem; }
        .stepper-btn { width: 16px; height: 16px; font-family: inherit; font-size: 0.65rem; font-weight: bold; background: #111; color: #f0f; border: 1px solid #a0a; border-radius: 2px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .stepper-btn:hover { background: #a0a; color: #000; }
        .stepper-val { min-width: 16px; text-align: center; font-size: 0.7rem; font-weight: bold; color: #f0f; }
        .peak-input { width: 40px; background: #111; border: 1px solid #a0a; color: #f0f; padding: 0.2rem; font-family: inherit; font-size: 0.65rem; text-align: center; }
        .peak-input:focus { outline: none; border-color: #f0f; }
        .pkt-row { display: flex; align-items: center; gap: 0.3rem; font-size: 0.6rem; margin-bottom: 0.2rem; }
        .pkt-row label { min-width: 50px; font-size: 0.55rem; }
        .section.tx-pkt .pkt-row label { color: #0a0; }
        .section.rx-pkt .pkt-row label { color: #0aa; }
        .section.tx-pkt .pkt-row input[type="text"] { border-color: #0a0; color: #0f0; }
        .section.tx-pkt .pkt-row input[type="number"] { border-color: #0a0; color: #0f0; width: 40px; }
        .section.rx-pkt .pkt-row input[type="text"] { border-color: #0aa; color: #0ff; }
        .section.rx-pkt .pkt-row input[type="number"] { border-color: #0aa; color: #0ff; width: 40px; }
        .pkt-row .ascii-display { font-size: 0.6rem; min-width: 35px; }
        .section.tx-pkt .ascii-display { color: #0f0; }
        .section.rx-pkt .ascii-display { color: #0ff; }
        .pkt-row .warn { color: #f00; font-size: 0.7rem; }
        .pkt-row .ok { font-size: 0.6rem; }
        .section.tx-pkt .ok { color: #0f0; }
        .section.rx-pkt .ok { color: #0ff; }
        .pkt-panels { display: flex; gap: 0.5rem; }
        .pkt-panels .section { flex: 1; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Signal Test v17</h1>
        
        <div class="section tx">
            <div class="section-title">‚ñ≤ Transmit</div>
            <div class="row">
                <label>Base</label>
                <input type="range" id="tx-slider" min="20" max="30000" step="10" value="18000">
                <input type="number" id="tx-input" value="18000" min="1" max="30000" step="1">
                <span class="hz">Hz</span>
            </div>
            <div class="row">
                <label>Step</label>
                <input type="number" id="tx-step" value="50" min="1" max="500" step="1" style="width:50px;">
                <span class="hz">Hz</span>
                <span class="range-display" id="tx-range-display"></span>
            </div>
            <div class="row">
                <label>Tol ¬±</label>
                <input type="number" id="tx-tolerance" value="4" min="1" max="100" step="1" style="width:40px;">
                <span class="hz">Hz per bit</span>
            </div>
            <div class="binary-row">
                <span class="binary-label">Binary</span>
                <div class="toggle-group" id="tx-toggles"></div>
                <span class="binary-string" id="tx-binary">00000000</span>
                <span class="ascii-char" id="tx-ascii">(NUL)</span>
            </div>
        </div>
        
        <div class="section rx">
            <div class="section-title">‚ñº Receive</div>
            <div class="row">
                <label>Base</label>
                <input type="range" id="rx-slider" min="20" max="30000" step="10" value="18000">
                <input type="number" id="rx-input" value="18000" min="1" max="30000" step="1">
                <span class="hz">Hz</span>
            </div>
            <div class="row">
                <label>Step</label>
                <input type="number" id="rx-step" value="50" min="1" max="500" step="1" style="width:50px;">
                <span class="hz">Hz</span>
                <span class="range-display" id="rx-range-display"></span>
            </div>
            <div class="row">
                <label>Tol ¬±</label>
                <input type="number" id="rx-tolerance" value="4" min="1" max="100" step="1" style="width:40px;">
                <span class="hz">Hz per bit</span>
            </div>
            <div class="row">
                <label>Threshold</label>
                <input type="number" id="rx-thresh" value="40" min="5" max="200" step="5" style="width:45px;">
                <span class="hz">power</span>
            </div>
            <div class="row">
                <label>Window</label>
                <input type="number" id="rx-window" value="300" min="10" max="2000" step="10" style="width:50px;">
                <span class="hz">ms debounce</span>
            </div>
            <div class="row">
                <label>Poll</label>
                <input type="number" id="poll-interval" value="50" min="10" max="500" step="10" style="width:45px;">
                <span class="hz">ms</span>
            </div>
            <div class="binary-row">
                <span class="binary-label">Expect</span>
                <div class="toggle-group" id="rx-toggles"></div>
                <span class="binary-string" id="rx-binary">00000000</span>
                <span class="ascii-char" id="rx-ascii">(NUL)</span>
            </div>
        </div>
        
        <div class="section peak">
            <div class="section-title">‚¨° Peak Detection</div>
            <div class="row">
                <label>Points</label>
                <div class="stepper">
                    <button class="stepper-btn" onclick="adjustPeakPoints(-1)">‚àí</button>
                    <span class="stepper-val" id="peak-points-val">1</span>
                    <button class="stepper-btn" onclick="adjustPeakPoints(1)">+</button>
                </div>
                <span class="range-display" id="peak-points-info">¬±50%</span>
                <label style="min-width:30px;">Ratio</label>
                <input type="number" id="peak-ratio" class="peak-input" value="1.0" min="1.0" max="3.0" step="0.1" style="width:40px;">
                <span class="hz">√ó</span>
                <button class="zoom-toggle" id="peak-enabled" onclick="togglePeakDetection()" style="border-color:#a0a;background:#a0a;color:#000;">ON</button>
            </div>
        </div>
        
        <div class="pkt-panels">
            <div class="section tx-pkt">
                <div class="section-title">üì§ TX Packet</div>
                <div class="pkt-row">
                    <label>Header</label>
                    <input type="text" id="tx-pkt-header" class="binary-input" value="10101010" maxlength="8" oninput="validatePktField(this, 'tx-pkt-header-status')">
                    <span id="tx-pkt-header-status" class="ok">‚úì</span>
                </div>
                <div class="pkt-row">
                    <label>Payload</label>
                    <input type="text" id="tx-pkt-payload" class="binary-input" value="00110001" maxlength="8" oninput="validatePktField(this, 'tx-pkt-payload-status')">
                    <span id="tx-pkt-payload-status" class="ok">‚úì</span>
                    <span class="hz">√ó</span>
                    <input type="number" id="tx-pkt-repeat" value="3" min="1" max="10" style="width:28px;">
                </div>
                <div class="pkt-row">
                    <label>Checksum</label>
                    <input type="text" id="tx-pkt-checksum" class="binary-input" value="01010101" maxlength="8" oninput="validatePktField(this, 'tx-pkt-checksum-status')">
                    <span id="tx-pkt-checksum-status" class="ok">‚úì</span>
                </div>
                <div class="pkt-row">
                    <label>Pulse</label>
                    <input type="number" id="tx-pkt-pulse-ms" value="200" min="20" max="2000" style="width:45px;">
                    <span class="hz">ms</span>
                </div>
                <div class="pkt-row">
                    <label>Gap</label>
                    <input type="number" id="tx-pkt-gap-ms" value="150" min="20" max="2000" style="width:45px;">
                    <span class="hz">ms</span>
                </div>
            </div>
            
            <div class="section rx-pkt">
                <div class="section-title">üì• RX Packet</div>
                <div class="pkt-row">
                    <label>Header</label>
                    <input type="text" id="rx-pkt-header" class="binary-input" value="10101010" maxlength="8" oninput="validatePktField(this, 'rx-pkt-header-status')">
                    <span id="rx-pkt-header-status" class="ok">‚úì</span>
                </div>
                <div class="pkt-row">
                    <label>Payload</label>
                    <input type="text" id="rx-pkt-payload" class="binary-input" value="00110001" maxlength="8" oninput="validatePktField(this, 'rx-pkt-payload-status')">
                    <span id="rx-pkt-payload-status" class="ok">‚úì</span>
                    <span class="hz">√ó</span>
                    <input type="number" id="rx-pkt-repeat" value="3" min="1" max="10" style="width:28px;">
                </div>
                <div class="pkt-row">
                    <label>Checksum</label>
                    <input type="text" id="rx-pkt-checksum" class="binary-input" value="01010101" maxlength="8" oninput="validatePktField(this, 'rx-pkt-checksum-status')">
                    <span id="rx-pkt-checksum-status" class="ok">‚úì</span>
                </div>
                <div class="pkt-row">
                    <label>Pulse</label>
                    <input type="number" id="rx-pkt-pulse-ms" value="200" min="20" max="2000" style="width:45px;">
                    <span class="hz">ms</span>
                </div>
                <div class="pkt-row">
                    <label>Gap</label>
                    <input type="number" id="rx-pkt-gap-ms" value="150" min="20" max="2000" style="width:45px;">
                    <span class="hz">ms</span>
                </div>
                <div class="pkt-row">
                    <label>Tolerance</label>
                    <input type="number" id="rx-pkt-tolerance-ms" value="20" min="5" max="500" style="width:45px;">
                    <span class="hz">ms ¬±</span>
                </div>
                <div class="pkt-row">
                    <label>Window</label>
                    <input type="number" id="rx-pkt-window-ms" value="5000" min="500" max="30000" style="width:50px;">
                    <span class="hz">ms</span>
                </div>
            </div>
        </div>
        
        <div class="air-toggle">
            <button class="air-btn" id="btn-air" onclick="toggleAir()">OFF AIR</button>
            <div class="pulse-group">
                <button class="pulse-btn" id="btn-pulse" onclick="manualPulse()" disabled>PULSE</button>
                <button class="pulse-btn packet-btn" id="btn-packet" onclick="sendPacket()" disabled>PACKET</button>
                <input type="number" id="pulse-duration" class="pulse-input" value="350" min="5" max="5000" step="5">
                <span class="pulse-label">ms</span>
            </div>
        </div>
        
        <div class="graph-section">
            <div class="graph-header">
                <span class="graph-title">Spectrum</span>
                <div class="graph-controls">
                    <button class="zoom-toggle" id="zoom-tx" onclick="toggleZoomTx()">Tx</button>
                    <button class="zoom-toggle" id="zoom-rx" onclick="toggleZoomRx()">Rx</button>
                    <span class="zoom-sep">‚îÇ</span>
                    <button class="zoom-btn" onclick="zoomGraph(-1)">‚àí</button>
                    <input type="number" id="hz-min" class="zoom-input" value="0" min="0" max="30000" step="100">
                    <span class="zoom-sep">‚Äì</span>
                    <input type="number" id="hz-max" class="zoom-input" value="4000" min="0" max="30000" step="100">
                    <span class="zoom-sep">Hz</span>
                    <button class="zoom-btn" onclick="zoomGraph(1)">+</button>
                    <span class="zoom-sep">‚îÇ</span>
                    <input type="number" id="pwr-min" class="zoom-input" value="0" min="0" max="255" step="5">
                    <span class="zoom-sep">‚Äì</span>
                    <input type="number" id="pwr-max" class="zoom-input" value="255" min="0" max="255" step="5">
                </div>
            </div>
            <div class="graph-container">
                <canvas id="graph"></canvas>
            </div>
        </div>
        
        <div class="detection-info" id="detection-info">‚Äî</div>
        
        <div class="status-row">
            <div class="status-box tx-status" id="tx-status">
                <div class="label">TX</div>
                <div class="pattern" id="tx-active-pattern">--------</div>
            </div>
            <div class="status-box rx-status" id="rx-status">
                <div class="label">RX</div>
                <div class="pattern" id="rx-detected-pattern">--------</div>
            </div>
            <div class="status-box pkt-status" id="pkt-status">
                <div class="label">Packet RX</div>
                <div class="pattern" id="pkt-detected-pattern">waiting...</div>
            </div>
        </div>
        
        <div class="timer" id="timer">00:10</div>
        
        <div class="log-header">
            <span class="log-title">Event Log</span>
            <div class="log-stats">
                <span id="tx-count">TX:0</span>
                <span id="rx-count">RX:0</span>
                <span id="pkt-count">PKT:0</span>
            </div>
        </div>
        <div class="log-panel" id="log"></div>
        
        <div class="button-row">
            <button class="main-btn btn-init" id="btn-init" onclick="init()">‚ö° INIT</button>
            <button class="main-btn btn-test" id="btn-test" onclick="startTest()" style="display:none;">‚ñ∂ TEST</button>
            <button class="main-btn btn-reset" onclick="resetAll()">‚Üª</button>
        </div>
        <div class="progress"><div class="progress-fill" id="progress"></div></div>
    </div>

    <script>
        const FFT_SIZE = 8192, NUM_BITS = 8;
        const ZOOM_LEVELS = [500, 1000, 2000, 4000, 8000, 12000, 20000, 30000];
        const HISTORY_SIZE = 500;
        
        let zoomIndex = 3;
        let hzMin = 0, hzMax = 4000, pwrMin = 0, pwrMax = 255;
        let zoomTxOn = false, zoomRxOn = false;
        let flashQueue = [], charFlashQueue = [], pktFlashQueue = [];
        let audioCtx, analyser, micStream, oscillators = [], gainNodes = [];
        let detectInterval, testInterval, frequencyData;
        let isInit = false, isRunning = false, isSending = false, isOnAir = false;
        let txBaseFreq = 18000, txStep = 50, txTolerance = 4, txToggles = [0,0,0,0,0,0,0,0];
        let rxBaseFreq = 18000, rxStep = 50, rxTolerance = 4, rxThreshold = 40, rxWindow = 300, pollInterval = 50, rxToggles = [0,0,0,0,0,0,0,0];
        let pulseDuration = 350, timeLeft = 10;
        
        let peakPoints = 1, peakRatio = 1.0, peakEnabled = true;
        let lastDetectionData = { powers: [], flankMaxLevels: [], peakValid: [] };
        
        let txState = { active: false, pattern: '00000000', startTime: 0 };
        let rxState = { lastPattern: '', lastTime: 0 };
        
        let txEventCount = 0, rxEventCount = 0, pktEventCount = 0;
        
        // Event history for backlog packet detection
        let eventHistory = [];
        
        let graphCanvas, graphCtx;
        
        const $ = id => document.getElementById(id);
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const togglesToString = t => t.map(x => x ? '1' : '0').join('');
        const stringToToggles = s => s.split('').map(c => c === '1' ? 1 : 0);
        const getAllFreqs = (base, step) => Array.from({length: NUM_BITS}, (_, i) => base + i * step);
        
        const binaryToAscii = b => parseInt(b, 2);
        const ctrlChars = {0:'NUL',1:'SOH',2:'STX',3:'ETX',4:'EOT',5:'ENQ',6:'ACK',7:'BEL',8:'BS',9:'TAB',10:'LF',11:'VT',12:'FF',13:'CR',14:'SO',15:'SI',16:'DLE',17:'DC1',18:'DC2',19:'DC3',20:'DC4',21:'NAK',22:'SYN',23:'ETB',24:'CAN',25:'EM',26:'SUB',27:'ESC',28:'FS',29:'GS',30:'RS',31:'US',32:'SPC',127:'DEL'};
        const getAsciiDisplay = c => ctrlChars[c] !== undefined ? `(${ctrlChars[c]})` : (c >= 33 && c <= 126) ? `'${String.fromCharCode(c)}'` : `(x${c.toString(16).toUpperCase()})`;
        const charSymbols = {0:'‚àÖ',8:'‚å´',9:'‚á•',10:'‚Üµ',13:'‚Ü©',32:'‚ê£',127:'‚å¶'};
        const getAsciiChar = c => charSymbols[c] || (c >= 33 && c <= 126 ? String.fromCharCode(c) : '?');
        
        function isValidBinary(s) { return /^[01]{8}$/.test(s); }
        
        function validatePktField(input, statusId) {
            const val = input.value;
            const status = $(statusId);
            if (isValidBinary(val)) {
                const ascii = getAsciiDisplay(binaryToAscii(val));
                status.className = 'ok';
                status.textContent = `‚úì ${ascii}`;
            } else {
                status.className = 'warn';
                status.textContent = '‚ö†';
            }
        }
        
        function getPeakCheckDistances() {
            if (peakPoints === 1) return [0.5];
            if (peakPoints === 2) return [0.25, 0.5];
            return [0.25, 0.5, 0.75];
        }
        
        function getPeakPointsInfo() {
            return '¬±' + getPeakCheckDistances().map(x => Math.round(x * 100) + '%').join(', ¬±');
        }
        
        function adjustPeakPoints(dir) {
            peakPoints = clamp(peakPoints + dir, 1, 3);
            $('peak-points-val').textContent = peakPoints;
            $('peak-points-info').textContent = getPeakPointsInfo();
        }
        
        function togglePeakDetection() {
            peakEnabled = !peakEnabled;
            const btn = $('peak-enabled');
            btn.textContent = peakEnabled ? 'ON' : 'OFF';
            btn.style.background = peakEnabled ? '#a0a' : '#111';
            btn.style.color = peakEnabled ? '#000' : '#555';
        }
        
        function checkPeak(centerPwr, freq, stepHz, binW, data) {
            const flankMaxLevel = centerPwr / peakRatio;
            if (!peakEnabled) return { valid: true, flankMaxLevel };
            const distances = getPeakCheckDistances();
            for (const side of [-1, 1]) {
                let lastPwr = centerPwr;
                for (let i = 0; i < distances.length; i++) {
                    const checkFreq = freq + (side * stepHz * distances[i]);
                    const checkBin = Math.round(checkFreq / binW);
                    const checkPwr = data[clamp(checkBin, 0, data.length - 1)] || 0;
                    if (i === 0) { if (checkPwr >= flankMaxLevel) return { valid: false, flankMaxLevel }; }
                    else { if (checkPwr > lastPwr) return { valid: false, flankMaxLevel }; }
                    lastPwr = checkPwr;
                }
            }
            return { valid: true, flankMaxLevel };
        }
        
        function log(type, pattern, ascii, extra = '') {
            const now = Date.now();
            const ts = new Date(now).toLocaleTimeString('en-US', {hour12:false,hour:'2-digit',minute:'2-digit',second:'2-digit'}) + '.' + (now % 1000).toString().padStart(3, '0');
            
            if (type === 'tx') { txEventCount++; $('tx-count').textContent = `TX:${txEventCount}`; }
            if (type === 'rx') { rxEventCount++; $('rx-count').textContent = `RX:${rxEventCount}`; }
            if (type === 'pkt') { pktEventCount++; $('pkt-count').textContent = `PKT:${pktEventCount}`; }
            
            const el = document.createElement('div');
            el.className = `log-entry ${type}`;
            const tag = type === 'tx' ? 'TX‚ñ≤' : type === 'rx' ? 'RX‚ñº' : type === 'pkt' ? 'PKT' : type === 'match' ? '‚úì‚úì' : type === 'info' ? '¬∑¬∑¬∑' : '!!!';
            const msg = pattern ? `${pattern} ${ascii}${extra ? ' ' + extra : ''}` : extra;
            el.innerHTML = `<span class="ts">${ts}</span><span class="tag">${tag}</span><span class="msg">${msg}</span>`;
            $('log').appendChild(el);
            $('log').scrollTop = $('log').scrollHeight;
        }
        
        // Store RX event in history for backlog analysis
        function recordRxEvent(pattern, time) {
            eventHistory.push({ pattern, time });
            if (eventHistory.length > HISTORY_SIZE) eventHistory.shift();
        }
        
        function updateTimer() {
            $('timer').textContent = `${Math.floor(timeLeft/60).toString().padStart(2,'0')}:${(timeLeft%60).toString().padStart(2,'0')}`;
        }
        
        function getTxRange() { return { min: txBaseFreq - txTolerance - txStep, max: txBaseFreq + 7 * txStep + txTolerance + txStep }; }
        function getRxRange() { return { min: rxBaseFreq - rxTolerance - rxStep, max: rxBaseFreq + 7 * rxStep + rxTolerance + rxStep }; }
        
        function applyZoomToggles() {
            if (!zoomTxOn && !zoomRxOn) return;
            let minHz = Infinity, maxHz = -Infinity;
            if (zoomTxOn) { const tx = getTxRange(); minHz = Math.min(minHz, tx.min); maxHz = Math.max(maxHz, tx.max); }
            if (zoomRxOn) { const rx = getRxRange(); minHz = Math.min(minHz, rx.min); maxHz = Math.max(maxHz, rx.max); }
            hzMin = Math.max(0, Math.floor(minHz)); hzMax = Math.ceil(maxHz);
            updateZoomInputs();
        }
        
        function toggleZoomTx() { zoomTxOn = !zoomTxOn; $('zoom-tx').classList.toggle('tx-on', zoomTxOn); applyZoomToggles(); }
        function toggleZoomRx() { zoomRxOn = !zoomRxOn; $('zoom-rx').classList.toggle('rx-on', zoomRxOn); applyZoomToggles(); }
        
        function zoomGraph(dir) {
            zoomTxOn = zoomRxOn = false;
            $('zoom-tx').classList.remove('tx-on'); $('zoom-rx').classList.remove('rx-on');
            zoomIndex = clamp(zoomIndex + dir, 0, ZOOM_LEVELS.length - 1);
            hzMax = ZOOM_LEVELS[zoomIndex]; hzMin = 0;
            updateZoomInputs();
        }
        
        function updateZoomInputs() {
            $('hz-min').value = hzMin; $('hz-max').value = hzMax;
            $('pwr-min').value = pwrMin; $('pwr-max').value = pwrMax;
        }
        
        function readZoomInputs() {
            zoomTxOn = zoomRxOn = false;
            $('zoom-tx').classList.remove('tx-on'); $('zoom-rx').classList.remove('rx-on');
            hzMin = clamp(parseInt($('hz-min').value) || 0, 0, 30000);
            hzMax = clamp(parseInt($('hz-max').value) || 4000, hzMin + 100, 30000);
            pwrMin = clamp(parseInt($('pwr-min').value) || 0, 0, 255);
            pwrMax = clamp(parseInt($('pwr-max').value) || 255, pwrMin + 10, 255);
            updateZoomInputs();
        }
        
        $('hz-min').onchange = $('hz-max').onchange = $('pwr-min').onchange = $('pwr-max').onchange = readZoomInputs;
        $('peak-ratio').onchange = () => { peakRatio = clamp(parseFloat($('peak-ratio').value) || 1.0, 1.0, 3.0); $('peak-ratio').value = peakRatio; };
        
        function triggerFlash() { flashQueue.push({ startTime: performance.now() }); }
        function triggerCharFlash(char) { charFlashQueue.push({ startTime: performance.now(), char }); }
        function triggerPktFlash(char) { pktFlashQueue.push({ startTime: performance.now(), char }); }
        
        function calculateFlashIntensity() {
            const now = performance.now();
            let intensity = 0;
            flashQueue = flashQueue.filter(f => {
                const elapsed = now - f.startTime;
                if (elapsed > 700) return false;
                intensity += elapsed < 200 ? 0.5 : 0.5 * (1 - (elapsed - 200) / 500);
                return true;
            });
            return Math.min(intensity, 1);
        }
        
        function calculatePktFlashIntensity() {
            const now = performance.now();
            let intensity = 0;
            pktFlashQueue = pktFlashQueue.filter(f => {
                const elapsed = now - f.startTime;
                if (elapsed > 1000) return false;
                intensity += elapsed < 300 ? 0.7 : 0.7 * (1 - (elapsed - 300) / 700);
                return true;
            });
            return Math.min(intensity, 1);
        }
        
        function getCharFlashState() {
            const now = performance.now();
            let result = { char: null, opacity: 0 };
            charFlashQueue = charFlashQueue.filter(f => {
                const elapsed = now - f.startTime;
                if (elapsed > 1000) return false;
                const opacity = elapsed < 300 ? Math.min(1, elapsed / 100) : 1 - (elapsed - 300) / 700;
                if (opacity > result.opacity) result = { char: f.char, opacity };
                return true;
            });
            return result;
        }
        
        function getPktCharFlashState() {
            const now = performance.now();
            let result = { char: null, opacity: 0 };
            pktFlashQueue = pktFlashQueue.filter(f => {
                const elapsed = now - f.startTime;
                if (elapsed > 1200) return false;
                const opacity = elapsed < 400 ? Math.min(1, elapsed / 150) : 1 - (elapsed - 400) / 800;
                if (opacity > result.opacity) result = { char: f.char, opacity };
                return true;
            });
            return result;
        }
        
        function createToggles(containerId, toggleArray, updateCallback) {
            const container = $(containerId);
            container.innerHTML = '';
            for (let i = 0; i < NUM_BITS; i++) {
                const btn = document.createElement('div');
                btn.className = 'bit-toggle' + (toggleArray[i] ? ' on' : '');
                btn.innerHTML = `<span class="bit-num">${i + 1}</span><span class="bit-val">${toggleArray[i]}</span>`;
                btn.onclick = () => {
                    toggleArray[i] = toggleArray[i] ? 0 : 1;
                    btn.classList.toggle('on', toggleArray[i]);
                    btn.querySelector('.bit-val').textContent = toggleArray[i];
                    updateCallback();
                };
                container.appendChild(btn);
            }
        }
        
        function updateTxDisplay() {
            const b = togglesToString(txToggles);
            $('tx-binary').textContent = b;
            $('tx-ascii').textContent = getAsciiDisplay(binaryToAscii(b));
            $('tx-range-display').textContent = `${txBaseFreq}‚Äì${txBaseFreq + 7*txStep} Hz`;
            if (zoomTxOn) applyZoomToggles();
        }
        
        function updateRxDisplay() {
            const b = togglesToString(rxToggles);
            $('rx-binary').textContent = b;
            $('rx-ascii').textContent = getAsciiDisplay(binaryToAscii(b));
            $('rx-range-display').textContent = `${rxBaseFreq}‚Äì${rxBaseFreq + 7*rxStep} Hz`;
            if (zoomRxOn) applyZoomToggles();
        }
        
        const updateTxBaseFreq = f => { txBaseFreq = clamp(Math.round(f), 1, 30000); $('tx-input').value = txBaseFreq; $('tx-slider').value = clamp(txBaseFreq, 20, 30000); updateTxDisplay(); };
        const updateRxBaseFreq = f => { rxBaseFreq = clamp(Math.round(f), 1, 30000); $('rx-input').value = rxBaseFreq; $('rx-slider').value = clamp(rxBaseFreq, 20, 30000); updateRxDisplay(); };
        
        $('tx-slider').oninput = () => updateTxBaseFreq(+$('tx-slider').value);
        $('tx-input').onchange = () => updateTxBaseFreq(+$('tx-input').value || 1);
        $('tx-step').onchange = () => { txStep = clamp(+$('tx-step').value || 50, 1, 500); updateTxDisplay(); };
        $('tx-tolerance').onchange = () => { txTolerance = clamp(+$('tx-tolerance').value || 4, 1, 100); updateTxDisplay(); };
        $('rx-slider').oninput = () => updateRxBaseFreq(+$('rx-slider').value);
        $('rx-input').onchange = () => updateRxBaseFreq(+$('rx-input').value || 1);
        $('rx-step').onchange = () => { rxStep = clamp(+$('rx-step').value || 50, 1, 500); updateRxDisplay(); };
        $('rx-tolerance').onchange = () => { rxTolerance = clamp(+$('rx-tolerance').value || 4, 1, 100); updateRxDisplay(); };
        $('rx-thresh').onchange = () => { rxThreshold = clamp(+$('rx-thresh').value || 40, 5, 200); };
        $('rx-window').onchange = () => { rxWindow = +$('rx-window').value || 300; };
        $('poll-interval').onchange = () => { 
            pollInterval = clamp(+$('poll-interval').value || 50, 10, 500); 
            if (isInit && detectInterval) { clearInterval(detectInterval); startDetection(); }
        };
        $('pulse-duration').onchange = () => { pulseDuration = clamp(+$('pulse-duration').value || 350, 5, 5000); };
        
        function toggleAir() {
            if (!isInit) return;
            isOnAir = !isOnAir;
            $('btn-air').classList.toggle('on', isOnAir);
            $('btn-air').textContent = isOnAir ? 'ON AIR' : 'OFF AIR';
            if (isOnAir) {
                log('info', '', '', '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ON AIR ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                eventHistory = [];
            } else {
                log('info', '', '', '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê OFF AIR ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                $('detection-info').textContent = '‚Äî';
                $('tx-active-pattern').textContent = '--------';
                $('rx-detected-pattern').textContent = '--------';
                $('pkt-detected-pattern').textContent = 'waiting...';
                $('tx-status').classList.remove('active');
                $('rx-status').classList.remove('match');
                $('pkt-status').classList.remove('pkt-ok');
            }
        }
        
        function manualPulse() {
            if (!isInit || isSending) return;
            if (!isOnAir) toggleAir();
            sendSignal();
        }
        
        // TX Packet
        async function sendPacket() {
            if (!isInit || isSending) return;
            if (!isOnAir) toggleAir();
            
            const header = $('tx-pkt-header').value;
            const payload = $('tx-pkt-payload').value;
            const checksum = $('tx-pkt-checksum').value;
            const repeat = parseInt($('tx-pkt-repeat').value) || 3;
            const pulseMs = parseInt($('tx-pkt-pulse-ms').value) || 200;
            const gapMs = parseInt($('tx-pkt-gap-ms').value) || 150;
            
            if (!isValidBinary(header) || !isValidBinary(payload) || !isValidBinary(checksum)) {
                log('err', '', '', 'Invalid TX packet config!');
                return;
            }
            
            log('pkt', '', '', `‚ñ∂ TX PKT [H:${header}][P:${payload}√ó${repeat}][C:${checksum}]`);
            
            await sendPatternPulse(header, pulseMs, 'H');
            await sleep(gapMs);
            
            for (let i = 0; i < repeat; i++) {
                await sendPatternPulse(payload, pulseMs, `P${i+1}`);
                if (i < repeat - 1) await sleep(gapMs);
            }
            await sleep(gapMs);
            
            await sendPatternPulse(checksum, pulseMs, 'C');
            
            log('pkt', '', '', '‚óº TX PKT END');
        }
        
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        
        async function sendPatternPulse(pattern, durMs, label) {
            return new Promise(resolve => {
                const toggles = stringToToggles(pattern);
                const charCode = binaryToAscii(pattern);
                
                log('tx', pattern, getAsciiDisplay(charCode), `[${label}] ${durMs}ms`);
                
                isSending = true;
                txState.active = true;
                txState.pattern = pattern;
                
                for (let i = 0; i < NUM_BITS; i++) {
                    oscillators[i].frequency.setValueAtTime(txBaseFreq + i * txStep, audioCtx.currentTime);
                    gainNodes[i].gain.setValueAtTime(toggles[i] ? 0.15 : 0, audioCtx.currentTime);
                }
                
                setTimeout(() => {
                    gainNodes.forEach(g => g.gain.setValueAtTime(0, audioCtx.currentTime));
                    setTimeout(() => {
                        isSending = false;
                        txState.active = false;
                        resolve();
                    }, 50);
                }, durMs);
            });
        }
        
        function setupGraph() {
            graphCanvas = $('graph');
            graphCtx = graphCanvas.getContext('2d');
            const rect = graphCanvas.getBoundingClientRect();
            graphCanvas.width = rect.width * devicePixelRatio;
            graphCanvas.height = rect.height * devicePixelRatio;
            graphCtx.scale(devicePixelRatio, devicePixelRatio);
        }
        
        function drawGraph() {
            if (!graphCtx) { requestAnimationFrame(drawGraph); return; }
            
            const w = graphCanvas.width / devicePixelRatio;
            const h = graphCanvas.height / devicePixelRatio;
            const flashIntensity = calculateFlashIntensity();
            const pktFlashIntensity = calculatePktFlashIntensity();
            const charFlash = getCharFlashState();
            const pktCharFlash = getPktCharFlashState();
            const hzRange = hzMax - hzMin;
            const pwrRange = pwrMax - pwrMin;
            
            // Background: cyan flash for pulse match, orange flash for packet
            let bgR = 5, bgG = 5, bgB = 5;
            if (pktFlashIntensity > 0) {
                bgR = 5 + 120 * pktFlashIntensity;
                bgG = 5 + 60 * pktFlashIntensity;
                bgB = 5;
            } else if (flashIntensity > 0) {
                bgG = 5 + 80 * flashIntensity;
                bgB = 5 + 80 * flashIntensity;
            }
            graphCtx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
            graphCtx.fillRect(0, 0, w, h);
            
            const hzToX = hz => ((hz - hzMin) / hzRange) * w;
            const pwrToY = pwr => h - ((clamp(pwr, pwrMin, pwrMax) - pwrMin) / pwrRange) * h;
            
            const txFreqs = getAllFreqs(txBaseFreq, txStep);
            const rxFreqs = getAllFreqs(rxBaseFreq, rxStep);
            
            // TX bands
            for (let i = 0; i < NUM_BITS; i++) {
                const freq = txFreqs[i];
                if (freq + txTolerance < hzMin || freq - txTolerance > hzMax) continue;
                const x1 = hzToX(freq - txTolerance), x2 = hzToX(freq + txTolerance);
                graphCtx.fillStyle = txToggles[i] ? 'rgba(0, 255, 0, 0.10)' : 'rgba(0, 255, 0, 0.03)';
                graphCtx.fillRect(x1, 0, Math.max(x2 - x1, 1), h);
                graphCtx.strokeStyle = txToggles[i] ? 'rgba(0, 255, 0, 0.4)' : 'rgba(0, 255, 0, 0.12)';
                graphCtx.beginPath(); graphCtx.moveTo(hzToX(freq), 0); graphCtx.lineTo(hzToX(freq), h); graphCtx.stroke();
            }
            
            // RX bands
            for (let i = 0; i < NUM_BITS; i++) {
                const freq = rxFreqs[i];
                if (freq + rxTolerance < hzMin || freq - rxTolerance > hzMax) continue;
                const x1 = hzToX(freq - rxTolerance), x2 = hzToX(freq + rxTolerance);
                graphCtx.fillStyle = rxToggles[i] ? 'rgba(0, 150, 255, 0.10)' : 'rgba(0, 150, 255, 0.03)';
                graphCtx.fillRect(x1, 0, Math.max(x2 - x1, 1), h);
                graphCtx.strokeStyle = rxToggles[i] ? 'rgba(0, 200, 255, 0.4)' : 'rgba(0, 150, 255, 0.12)';
                graphCtx.beginPath(); graphCtx.moveTo(hzToX(freq), 0); graphCtx.lineTo(hzToX(freq), h); graphCtx.stroke();
                
                graphCtx.fillStyle = rxToggles[i] ? 'rgba(0, 200, 255, 0.6)' : 'rgba(100, 100, 100, 0.3)';
                graphCtx.font = '7px Courier New';
                graphCtx.fillText(i + 1, hzToX(freq) - 2, 9);
                
                if (peakEnabled && lastDetectionData.flankMaxLevels[i] > 0) {
                    const flankMax = lastDetectionData.flankMaxLevels[i];
                    const threshY = pwrToY(flankMax);
                    graphCtx.strokeStyle = lastDetectionData.peakValid[i] ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 100, 0, 0.5)';
                    graphCtx.setLineDash([3, 3]);
                    graphCtx.beginPath();
                    graphCtx.moveTo(Math.max(0, hzToX(freq - rxStep * 0.5)), threshY);
                    graphCtx.lineTo(Math.min(w, hzToX(freq + rxStep * 0.5)), threshY);
                    graphCtx.stroke();
                    graphCtx.setLineDash([]);
                }
            }
            
            // Spectrum
            if (isOnAir && analyser) {
                analyser.getByteFrequencyData(frequencyData);
                const binW = audioCtx.sampleRate / analyser.fftSize;
                const startBin = Math.max(0, Math.floor(hzMin / binW));
                const endBin = Math.min(frequencyData.length, Math.ceil(hzMax / binW));
                
                for (let i = startBin; i < endBin; i++) {
                    const freq = i * binW, pwr = frequencyData[i];
                    if (pwr < pwrMin) continue;
                    const x = hzToX(freq);
                    const barH = ((Math.min(pwr, pwrMax) - pwrMin) / pwrRange) * h;
                    const v = pwr / 255;
                    
                    let inTx = isSending && stringToToggles(txState.pattern).some((t, j) => t && Math.abs(freq - txFreqs[j]) <= txTolerance);
                    let inRx = rxFreqs.some((f) => Math.abs(freq - f) <= rxTolerance);
                    
                    graphCtx.fillStyle = inTx ? `rgba(0, 255, 0, ${0.4 + v * 0.6})` : 
                                         inRx ? `rgba(0, 200, 255, ${0.3 + v * 0.7})` : 
                                         `rgba(100, 100, 100, ${0.2 + v * 0.6})`;
                    
                    graphCtx.fillRect(x, h - barH, Math.max(w / (endBin - startBin) - 1, 1), barH);
                }
            }
            
            // Threshold
            if (rxThreshold >= pwrMin && rxThreshold <= pwrMax) {
                const threshY = pwrToY(rxThreshold);
                graphCtx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                graphCtx.setLineDash([3, 3]);
                graphCtx.beginPath(); graphCtx.moveTo(0, threshY); graphCtx.lineTo(w, threshY); graphCtx.stroke();
                graphCtx.setLineDash([]);
            }
            
            // Freq markers
            graphCtx.fillStyle = '#444';
            graphCtx.font = '8px Courier New';
            const step = hzRange <= 500 ? 100 : hzRange <= 1000 ? 200 : hzRange <= 4000 ? 500 : hzRange <= 10000 ? 2000 : 5000;
            for (let f = Math.ceil(hzMin / step) * step; f <= hzMax; f += step) {
                graphCtx.fillText(f >= 1000 ? `${f/1000}k` : f, hzToX(f) - 8, h - 2);
            }
            
            // Char flash (cyan for pulse match)
            if (charFlash.char && charFlash.opacity > 0) {
                graphCtx.save();
                graphCtx.font = 'bold 40px Courier New';
                graphCtx.textAlign = 'center';
                graphCtx.textBaseline = 'middle';
                graphCtx.shadowColor = `rgba(0, 255, 255, ${charFlash.opacity})`;
                graphCtx.shadowBlur = 20;
                graphCtx.fillStyle = `rgba(0, 255, 255, ${charFlash.opacity})`;
                graphCtx.fillText(charFlash.char, w / 2, h / 2);
                graphCtx.restore();
            }
            
            // Packet char flash (orange)
            if (pktCharFlash.char && pktCharFlash.opacity > 0) {
                graphCtx.save();
                graphCtx.font = 'bold 48px Courier New';
                graphCtx.textAlign = 'center';
                graphCtx.textBaseline = 'middle';
                graphCtx.shadowColor = `rgba(255, 170, 0, ${pktCharFlash.opacity})`;
                graphCtx.shadowBlur = 25;
                graphCtx.fillStyle = `rgba(255, 170, 0, ${pktCharFlash.opacity})`;
                graphCtx.fillText(pktCharFlash.char, w / 2, h / 2);
                graphCtx.restore();
            }
            
            requestAnimationFrame(drawGraph);
        }
        
        async function init() {
            if (isInit) return;
            $('btn-init').disabled = true;
            log('info', '', '', 'Initializing...');
            
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                
                micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                log('info', '', '', 'Microphone ready ‚úì');
                
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = 0.3;
                audioCtx.createMediaStreamSource(micStream).connect(analyser);
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                
                for (let i = 0; i < NUM_BITS; i++) {
                    const gain = audioCtx.createGain();
                    gain.gain.value = 0;
                    gain.connect(audioCtx.destination);
                    gainNodes.push(gain);
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = txBaseFreq + i * txStep;
                    osc.connect(gain);
                    osc.start();
                    oscillators.push(osc);
                }
                
                setupGraph();
                startDetection();
                requestAnimationFrame(drawGraph);
                
                isInit = true;
                $('btn-init').style.display = 'none';
                $('btn-test').style.display = 'block';
                $('btn-pulse').disabled = false;
                $('btn-packet').disabled = false;
                
                ['tx-pkt-header', 'tx-pkt-payload', 'tx-pkt-checksum', 'rx-pkt-header', 'rx-pkt-payload', 'rx-pkt-checksum'].forEach(id => {
                    validatePktField($(id), id + '-status');
                });
                
                log('info', '', '', '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê READY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            } catch (e) {
                log('err', '', '', `ERROR: ${e.message}`);
                $('btn-init').disabled = false;
            }
        }
        
        function startDetection() {
            const binW = audioCtx.sampleRate / analyser.fftSize;
            const data = new Uint8Array(analyser.frequencyBinCount);
            
            detectInterval = setInterval(() => {
                if (!analyser || !isOnAir) return;
                
                analyser.getByteFrequencyData(data);
                const rxFreqs = getAllFreqs(rxBaseFreq, rxStep);
                const now = Date.now();
                
                const detected = [], powers = [], peakResults = [], flankMaxLevels = [];
                
                for (let i = 0; i < NUM_BITS; i++) {
                    const freq = rxFreqs[i];
                    const lo = Math.max(0, Math.floor((freq - rxTolerance) / binW));
                    const hi = Math.min(data.length - 1, Math.ceil((freq + rxTolerance) / binW));
                    let maxP = 0;
                    for (let b = lo; b <= hi; b++) if (data[b] > maxP) maxP = data[b];
                    powers.push(maxP);
                    
                    const aboveThresh = maxP >= rxThreshold;
                    let peakResult = { valid: true, flankMaxLevel: 0 };
                    if (aboveThresh) peakResult = checkPeak(maxP, freq, rxStep, binW, data);
                    peakResults.push(peakResult.valid);
                    flankMaxLevels.push(aboveThresh ? peakResult.flankMaxLevel : 0);
                    detected.push((aboveThresh && peakResult.valid) ? 1 : 0);
                }
                
                lastDetectionData = { powers, flankMaxLevels, peakValid: peakResults };
                
                const rxDetStr = togglesToString(detected);
                const rxDetCharCode = binaryToAscii(rxDetStr);
                
                $('tx-active-pattern').textContent = isSending ? `${txState.pattern} ${getAsciiDisplay(binaryToAscii(txState.pattern))}` : '--------';
                $('tx-status').classList.toggle('active', isSending);
                $('rx-detected-pattern').textContent = `${rxDetStr} ${getAsciiDisplay(rxDetCharCode)}`;
                
                const txInfo = isSending ? `TX:${txState.pattern}` : 'TX:idle';
                $('detection-info').innerHTML = `${txInfo} | RX:${rxDetStr}`;
                
                // RX pulse detection
                if (detected.some(b => b)) {
                    if (now - rxState.lastTime > rxWindow || rxDetStr !== rxState.lastPattern) {
                        rxState.lastTime = now;
                        rxState.lastPattern = rxDetStr;
                        
                        // Record in history for packet detection
                        recordRxEvent(rxDetStr, now);
                        
                        const expStr = togglesToString(rxToggles);
                        const isMatch = rxDetStr === expStr;
                        $('rx-status').classList.toggle('match', isMatch);
                        
                        log('rx', rxDetStr, getAsciiDisplay(rxDetCharCode), isSending ? '[during TX]' : '');
                        
                        if (isMatch) {
                            log('match', rxDetStr, getAsciiDisplay(rxDetCharCode), '= expected');
                            triggerFlash();
                            triggerCharFlash(getAsciiChar(rxDetCharCode));
                        }
                        
                        // Check for packet completion using backlog
                        checkPacketFromBacklog(now);
                    }
                } else {
                    $('rx-status').classList.remove('match');
                }
            }, pollInterval);
        }
        
        // Backlog-based packet detection
        function checkPacketFromBacklog(now) {
            const header = $('rx-pkt-header').value;
            const expectedPayload = $('rx-pkt-payload').value;
            const checksum = $('rx-pkt-checksum').value;
            const expectedRepeat = parseInt($('rx-pkt-repeat').value) || 3;
            const pulseMs = parseInt($('rx-pkt-pulse-ms').value) || 200;
            const gapMs = parseInt($('rx-pkt-gap-ms').value) || 150;
            const toleranceMs = parseInt($('rx-pkt-tolerance-ms').value) || 20;
            const windowMs = parseInt($('rx-pkt-window-ms').value) || 5000;
            
            if (!isValidBinary(header) || !isValidBinary(expectedPayload) || !isValidBinary(checksum)) return;
            
            // Find most recent checksum in history
            const recentEvents = eventHistory.filter(e => now - e.time <= windowMs);
            
            // Look for checksum matches
            for (let ci = recentEvents.length - 1; ci >= 0; ci--) {
                const checksumEvent = recentEvents[ci];
                if (checksumEvent.pattern !== checksum) continue;
                
                // Look for a header before this checksum
                for (let hi = ci - 1; hi >= 0; hi--) {
                    const headerEvent = recentEvents[hi];
                    if (headerEvent.pattern !== header) continue;
                    
                    const headerTime = headerEvent.time;
                    const checksumTime = checksumEvent.time;
                    
                    // Calculate expected timing
                    // Header -> gap -> P1 -> gap -> P2 -> ... -> gap -> Checksum
                    // P[i] expected at: headerTime + pulseMs + gapMs + i * (pulseMs + gapMs)
                    // Checksum expected at: headerTime + pulseMs + gapMs + expectedRepeat * (pulseMs + gapMs)
                    
                    const expectedChecksumTime = headerTime + pulseMs + gapMs + expectedRepeat * (pulseMs + gapMs);
                    const checksumTimeDiff = Math.abs(checksumTime - expectedChecksumTime);
                    
                    // Check if checksum timing is within reasonable range (use larger tolerance for checksum)
                    if (checksumTimeDiff > toleranceMs * 3 + expectedRepeat * toleranceMs) continue;
                    
                    // Find payloads between header and checksum
                    const payloads = [];
                    for (let pi = hi + 1; pi < ci; pi++) {
                        const payloadEvent = recentEvents[pi];
                        // Check if this event falls within expected payload timing slots
                        for (let slot = 0; slot < expectedRepeat; slot++) {
                            const expectedPayloadTime = headerTime + pulseMs + gapMs + slot * (pulseMs + gapMs);
                            const timeDiff = Math.abs(payloadEvent.time - expectedPayloadTime);
                            if (timeDiff <= toleranceMs) {
                                payloads.push({ slot, pattern: payloadEvent.pattern, time: payloadEvent.time });
                                break;
                            }
                        }
                    }
                    
                    // Need at least 1 payload
                    if (payloads.length === 0) continue;
                    
                    // Compute average payload via majority voting
                    const avgPayload = computeAveragePayload(payloads.map(p => p.pattern));
                    
                    // Mark these events as consumed (prevent re-triggering)
                    // Remove from history
                    const usedIndices = new Set([hi, ci, ...payloads.map(p => recentEvents.indexOf(recentEvents.find(e => e.time === p.time)))]);
                    eventHistory = eventHistory.filter((e, i) => {
                        const idx = recentEvents.indexOf(e);
                        return idx === -1 || !usedIndices.has(idx);
                    });
                    
                    // Report packet
                    const avgPayloadChar = binaryToAscii(avgPayload);
                    $('pkt-detected-pattern').textContent = `‚úì ${avgPayload} ${getAsciiDisplay(avgPayloadChar)}`;
                    $('pkt-status').classList.add('pkt-ok');
                    
                    log('pkt', '', '', `‚úì‚úì RX PKT [H:${header}][P:${avgPayload}√ó${payloads.length}][C:${checksum}]`);
                    log('pkt', avgPayload, getAsciiDisplay(avgPayloadChar), `‚Üê Payload (${payloads.length} samples)`);
                    
                    triggerPktFlash(getAsciiChar(avgPayloadChar));
                    
                    setTimeout(() => {
                        $('pkt-detected-pattern').textContent = 'waiting...';
                        $('pkt-status').classList.remove('pkt-ok');
                    }, 2000);
                    
                    return; // Found a valid packet
                }
            }
        }
        
        function computeAveragePayload(payloads) {
            if (payloads.length === 0) return '00000000';
            const result = [];
            for (let i = 0; i < NUM_BITS; i++) {
                let ones = 0;
                for (const p of payloads) {
                    if (p[i] === '1') ones++;
                }
                result.push(ones > payloads.length / 2 ? '1' : '0');
            }
            return result.join('');
        }
        
        function sendSignal() {
            const pattern = togglesToString(txToggles);
            sendPatternPulse(pattern, pulseDuration, 'P');
        }
        
        function startTest() {
            if (!isInit || isRunning) return;
            if (!isOnAir) toggleAir();
            isRunning = true;
            timeLeft = 10;
            $('btn-test').disabled = true;
            $('timer').classList.add('active');
            log('info', '', '', '‚ïê‚ïê‚ïê TEST START ‚ïê‚ïê‚ïê');
            sendSignal();
            updateTimer();
            testInterval = setInterval(() => {
                timeLeft--;
                updateTimer();
                $('progress').style.width = `${((10 - timeLeft) / 10) * 100}%`;
                if (timeLeft % 2 === 0 && timeLeft > 0) sendSignal();
                if (timeLeft <= 0) endTest();
            }, 1000);
        }
        
        function endTest() {
            isRunning = false;
            clearInterval(testInterval);
            $('timer').classList.remove('active');
            $('btn-test').disabled = false;
            $('progress').style.width = '100%';
            log('info', '', '', '‚ïê‚ïê‚ïê TEST END ‚ïê‚ïê‚ïê');
        }
        
        function resetAll() {
            clearInterval(testInterval);
            isRunning = false;
            timeLeft = 10;
            updateTimer();
            $('progress').style.width = '0%';
            $('timer').classList.remove('active');
            $('btn-test').disabled = false;
            $('detection-info').textContent = '‚Äî';
            $('log').innerHTML = '';
            flashQueue = [];
            charFlashQueue = [];
            pktFlashQueue = [];
            txEventCount = rxEventCount = pktEventCount = 0;
            eventHistory = [];
            rxState = { lastPattern: '', lastTime: 0 };
            txState = { active: false, pattern: '00000000', startTime: 0 };
            lastDetectionData = { powers: [], flankMaxLevels: [], peakValid: [] };
            $('tx-active-pattern').textContent = '--------';
            $('rx-detected-pattern').textContent = '--------';
            $('pkt-detected-pattern').textContent = 'waiting...';
            $('tx-status').classList.remove('active');
            $('rx-status').classList.remove('match');
            $('pkt-status').classList.remove('pkt-ok');
            $('tx-count').textContent = 'TX:0';
            $('rx-count').textContent = 'RX:0';
            $('pkt-count').textContent = 'PKT:0';
            log('info', '', '', 'Reset');
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            createToggles('tx-toggles', txToggles, updateTxDisplay);
            createToggles('rx-toggles', rxToggles, updateRxDisplay);
            updateTxBaseFreq(txBaseFreq);
            updateRxBaseFreq(rxBaseFreq);
            updateZoomInputs();
            $('peak-points-info').textContent = getPeakPointsInfo();
            setupGraph();
            requestAnimationFrame(drawGraph);
            log('info', '', '', 'Audio Signal Test v17');
            log('info', '', '', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            log('info', '', '', 'üì¶ Timing-validated packets');
        });
        
        window.addEventListener('resize', () => { if (graphCanvas) setupGraph(); });
    </script>
</body>
</html>
