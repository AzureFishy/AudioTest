<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Signal Test v24</title>
    <style>
        /* === Base Styles === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #000; color: #fff; min-height: 100vh; padding: 0.75rem; font-size: 12px; }
        .container { max-width: 580px; margin: 0 auto; border: 1px solid #fff; padding: 1rem; }
        h1 { font-size: 0.9rem; font-weight: normal; text-transform: uppercase; letter-spacing: 0.15em; margin-bottom: 0.75rem; text-align: center; border-bottom: 1px solid #333; padding-bottom: 0.4rem; }
        
        /* === Section Styles === */
        .section { margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #333; }
        .section.tx { border-color: #0a0; }
        .section.rx { border-color: #0aa; }
        .section.denoise { border-color: #a80; }
        .section.patbuf { border-color: #08a; }
        .section-title { font-size: 0.6rem; color: #666; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.3rem; display: flex; justify-content: space-between; align-items: center; }
        .section.tx .section-title { color: #0f0; }
        .section.rx .section-title { color: #0ff; }
        .section.denoise .section-title { color: #fa0; }
        .section.patbuf .section-title { color: #0af; }
        
        /* === Row & Input Styles === */
        .row { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.25rem; font-size: 0.65rem; flex-wrap: wrap; }
        .row:last-child { margin-bottom: 0; }
        .row label { color: #888; min-width: 50px; flex-shrink: 0; }
        input[type="range"] { flex: 1; height: 4px; -webkit-appearance: none; background: #333; outline: none; min-width: 60px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #fff; cursor: pointer; border-radius: 50%; }
        .section.tx input[type="range"]::-webkit-slider-thumb { background: #0f0; }
        .section.rx input[type="range"]::-webkit-slider-thumb { background: #0ff; }
        .section.denoise input[type="range"]::-webkit-slider-thumb { background: #fa0; }
        .section.patbuf input[type="range"]::-webkit-slider-thumb { background: #0af; }
        input[type="number"], input[type="text"] { background: #111; border: 1px solid #444; color: #fff; padding: 0.2rem 0.25rem; font-family: inherit; font-size: 0.65rem; text-align: center; }
        input[type="number"] { width: 50px; }
        input[type="number"]:focus, input[type="text"]:focus { outline: none; border-color: #fff; }
        .hz { font-size: 0.55rem; color: #666; }
        .range-display { font-size: 0.55rem; color: #666; margin-left: auto; }
        .section.tx .range-display { color: #0a0; }
        .section.rx .range-display { color: #0aa; }
        .section.denoise .range-display { color: #a80; }
        .section.patbuf .range-display { color: #08a; }
        
        /* === Binary Toggle Styles === */
        .binary-row { display: flex; align-items: center; gap: 0.25rem; margin-top: 0.4rem; padding-top: 0.4rem; border-top: 1px solid #222; flex-wrap: wrap; }
        .binary-label { font-size: 0.55rem; color: #666; min-width: 40px; }
        .section.tx .binary-label { color: #0a0; }
        .section.rx .binary-label { color: #0aa; }
        .toggle-group { display: flex; gap: 1px; }
        .bit-toggle { width: 24px; height: 26px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #111; border: 1px solid #333; border-radius: 2px; cursor: pointer; transition: all 0.15s; position: relative; }
        .bit-toggle:hover { border-color: #555; }
        .bit-toggle.on { background: #0a0; border-color: #0f0; }
        .section.rx .bit-toggle.on { background: #088; border-color: #0ff; }
        .bit-toggle .bit-num { font-size: 0.45rem; color: #555; position: absolute; top: 1px; }
        .bit-toggle.on .bit-num { color: #000; }
        .bit-toggle .bit-val { font-size: 0.7rem; font-weight: bold; color: #444; }
        .bit-toggle.on .bit-val { color: #000; }
        .binary-string { font-size: 0.6rem; color: #555; font-family: inherit; letter-spacing: 0.05em; margin-left: 0.3rem; }
        .section.tx .binary-string { color: #0a0; }
        .section.rx .binary-string { color: #0aa; }
        .ascii-char { font-size: 0.65rem; font-weight: bold; margin-left: 0.2rem; padding: 0.1rem 0.25rem; background: #1a1a1a; border-radius: 2px; }
        .section.tx .ascii-char { color: #0f0; border: 1px solid #0a0; }
        .section.rx .ascii-char { color: #0ff; border: 1px solid #0aa; }
        
        /* === Air & Pulse Controls === */
        .air-toggle { display: flex; justify-content: center; align-items: center; gap: 0.4rem; margin: 0.75rem 0; flex-wrap: wrap; }
        .air-btn { padding: 0.4rem 1.2rem; font-family: inherit; font-size: 0.7rem; font-weight: bold; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; border: 2px solid #444; background: #111; color: #666; border-radius: 4px; transition: all 0.2s; }
        .air-btn:hover { border-color: #666; }
        .air-btn.on { background: #f00; color: #fff; border-color: #f00; box-shadow: 0 0 15px rgba(255, 0, 0, 0.5); animation: air-pulse 1.5s infinite; }
        @keyframes air-pulse { 0%, 100% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.5); } 50% { box-shadow: 0 0 25px rgba(255, 0, 0, 0.8); } }
        .pulse-group { display: flex; align-items: center; gap: 0.25rem; }
        .pulse-btn { padding: 0.4rem 0.6rem; font-family: inherit; font-size: 0.7rem; font-weight: bold; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; border: 2px solid #0a0; background: #111; color: #0f0; border-radius: 4px; transition: all 0.1s; }
        .pulse-btn:hover { background: #0a0; color: #000; }
        .pulse-btn:active { background: #0f0; }
        .pulse-btn:disabled { border-color: #333; color: #333; cursor: not-allowed; }
        .pulse-btn:disabled:hover { background: #111; color: #333; }
        .pulse-input { width: 42px; background: #111; border: 1px solid #0a0; color: #0f0; padding: 0.3rem 0.2rem; font-family: inherit; font-size: 0.6rem; text-align: center; border-radius: 3px; }
        .pulse-input:focus { outline: none; border-color: #0f0; }
        .pulse-label { font-size: 0.5rem; color: #0a0; }
        .pulse-expander { width: 20px; height: 20px; font-family: inherit; font-size: 0.7rem; background: #111; color: #0a0; border: 1px solid #0a0; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .pulse-expander:hover { background: #0a0; color: #000; }
        
        /* === Advanced Pulse Panel === */
        .adv-pulse { margin: 0.5rem 0; padding: 0.5rem; border: 1px solid #0a0; background: rgba(0, 50, 0, 0.1); display: none; }
        .adv-pulse.open { display: block; }
        .adv-pulse-title { font-size: 0.55rem; color: #0a0; text-transform: uppercase; margin-bottom: 0.3rem; }
        .adv-pulse-row { display: flex; align-items: center; gap: 0.3rem; margin-bottom: 0.25rem; font-size: 0.6rem; flex-wrap: wrap; }
        .adv-pulse-row label { color: #0a0; min-width: 45px; font-size: 0.55rem; }
        .adv-pulse-row input[type="text"] { flex: 1; min-width: 120px; text-align: left; padding-left: 0.4rem; border-color: #0a0; color: #0f0; }
        .adv-pulse-row input[type="number"] { width: 45px; border-color: #0a0; color: #0f0; }
        .adv-pulse-btn { padding: 0.35rem 0.8rem; font-family: inherit; font-size: 0.65rem; font-weight: bold; text-transform: uppercase; cursor: pointer; border: 2px solid #0a0; background: #111; color: #0f0; border-radius: 4px; }
        .adv-pulse-btn:hover { background: #0a0; color: #000; }
        .adv-pulse-btn.running { background: #a00; border-color: #f00; color: #fff; animation: seq-pulse 0.8s infinite; }
        @keyframes seq-pulse { 50% { opacity: 0.7; } }
        .adv-pulse-status { font-size: 0.5rem; color: #0a0; margin-left: 0.3rem; }
        
        /* === Graph Styles === */
        .graph-section { margin-bottom: 0.5rem; }
        .graph-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem; gap: 0.4rem; flex-wrap: wrap; }
        .graph-title { font-size: 0.55rem; color: #666; text-transform: uppercase; }
        .graph-controls { display: flex; align-items: center; gap: 0.15rem; flex-wrap: wrap; }
        .zoom-btn { width: 18px; height: 18px; font-family: inherit; font-size: 0.75rem; font-weight: bold; background: #111; color: #888; border: 1px solid #444; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 1; }
        .zoom-btn:hover { background: #222; color: #fff; border-color: #666; }
        .zoom-toggle { padding: 0.1rem 0.3rem; font-family: inherit; font-size: 0.5rem; font-weight: bold; background: #111; color: #555; border: 1px solid #333; border-radius: 3px; cursor: pointer; text-transform: uppercase; }
        .zoom-toggle:hover { border-color: #555; color: #888; }
        .zoom-toggle.tx-on { background: #0a0; color: #000; border-color: #0f0; }
        .zoom-toggle.rx-on { background: #088; color: #000; border-color: #0ff; }
        .zoom-input { width: 40px; background: #111; border: 1px solid #333; color: #888; padding: 0.15rem; font-family: inherit; font-size: 0.5rem; text-align: center; border-radius: 2px; }
        .zoom-input:focus { outline: none; border-color: #666; color: #fff; }
        .zoom-sep { color: #333; font-size: 0.45rem; }
        .graph-container { border: 1px solid #222; background: #050505; position: relative; overflow: hidden; }
        #graph { width: 100%; height: 100px; display: block; }
        
        /* === Button Row === */
        .button-row { display: flex; gap: 0.4rem; margin-top: 0.5rem; }
        button.main-btn { flex: 1; padding: 0.5rem; font-family: inherit; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; border: none; transition: all 0.15s; }
        .btn-init { background: #fff; color: #000; }
        .btn-reset { background: transparent; color: #fff; border: 1px solid #555 !important; }
        button.main-btn:disabled { background: #333; color: #666; cursor: not-allowed; }
        button.main-btn:hover:not(:disabled) { opacity: 0.8; }
        
        /* === De-noise Styles === */
        .denoise-controls { display: flex; align-items: center; gap: 0.4rem; flex-wrap: wrap; }
        .denoise-btn { padding: 0.3rem 0.5rem; font-family: inherit; font-size: 0.6rem; font-weight: bold; text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; border: 2px solid #a80; background: #111; color: #fa0; border-radius: 4px; transition: all 0.15s; }
        .denoise-btn:hover { background: #a80; color: #000; }
        .denoise-btn:disabled { border-color: #333; color: #333; cursor: not-allowed; }
        .denoise-btn:disabled:hover { background: #111; color: #333; }
        .denoise-btn.listening { background: #fa0; color: #000; animation: listen-pulse 0.5s infinite; }
        @keyframes listen-pulse { 50% { opacity: 0.6; } }
        .denoise-input { width: 45px; background: #111; border: 1px solid #a80; color: #fa0; padding: 0.2rem; font-family: inherit; font-size: 0.6rem; text-align: center; border-radius: 3px; }
        .denoise-input:focus { outline: none; border-color: #fa0; }
        .denoise-master { display: flex; align-items: center; gap: 0.3rem; margin-top: 0.3rem; padding-top: 0.3rem; border-top: 1px solid #222; }
        .denoise-master label { font-size: 0.55rem; color: #a80; min-width: 45px; }
        .denoise-master input[type="range"] { flex: 1; }
        .denoise-master .master-val { font-size: 0.55rem; color: #fa0; min-width: 28px; text-align: right; }
        .denoise-toggle { padding: 0.15rem 0.4rem; font-family: inherit; font-size: 0.5rem; font-weight: bold; background: #111; color: #555; border: 1px solid #333; border-radius: 3px; cursor: pointer; text-transform: uppercase; }
        .denoise-toggle:hover { border-color: #555; color: #888; }
        .denoise-toggle.on { background: #a80; color: #000; border-color: #fa0; }
        
        /* === Noise Profile Styles === */
        .noise-profiles { margin-top: 0.4rem; max-height: 150px; overflow-y: auto; }
        .noise-profile { display: flex; align-items: center; gap: 0.3rem; padding: 0.3rem; margin-bottom: 0.25rem; background: #0a0a0a; border: 1px solid #333; border-radius: 3px; }
        .noise-profile:hover { border-color: #a80; }
        .noise-profile-canvas { width: 60px; height: 24px; border: 1px solid #444; background: #050505; flex-shrink: 0; }
        .noise-profile-info { flex: 1; display: flex; flex-direction: column; gap: 0.15rem; min-width: 0; }
        .noise-profile-name { display: flex; align-items: center; gap: 0.2rem; }
        .noise-profile-name input { flex: 1; min-width: 60px; font-size: 0.5rem; padding: 0.15rem 0.25rem; background: #111; border: 1px solid #555; color: #fa0; text-align: left; border-radius: 2px; }
        .noise-profile-name input:focus { border-color: #fa0; }
        .noise-profile-meta { font-size: 0.45rem; color: #666; }
        .noise-profile-slider { display: flex; align-items: center; gap: 0.2rem; }
        .noise-profile-slider input[type="range"] { flex: 1; min-width: 40px; height: 3px; }
        .noise-profile-slider .slider-val { font-size: 0.5rem; color: #fa0; min-width: 22px; text-align: right; }
        .noise-profile-del { width: 16px; height: 16px; font-family: inherit; font-size: 0.7rem; font-weight: bold; background: #111; color: #666; border: 1px solid #444; border-radius: 2px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .noise-profile-del:hover { background: #600; color: #f00; border-color: #f00; }
        .no-profiles { font-size: 0.5rem; color: #444; text-align: center; padding: 0.5rem; font-style: italic; }
        
        /* === Pattern Buffer Styles === */
        .patbuf-controls { display: flex; align-items: center; gap: 0.4rem; flex-wrap: wrap; margin-bottom: 0.3rem; }
        .patbuf-btn { padding: 0.3rem 0.5rem; font-family: inherit; font-size: 0.6rem; font-weight: bold; text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; border: 2px solid #08a; background: #111; color: #0af; border-radius: 4px; transition: all 0.15s; }
        .patbuf-btn:hover { background: #08a; color: #000; }
        .patbuf-btn:disabled { border-color: #333; color: #333; cursor: not-allowed; }
        .patbuf-btn:disabled:hover { background: #111; color: #333; }
        .patbuf-btn.recording { background: #0af; color: #000; animation: rec-pulse 0.8s infinite; }
        @keyframes rec-pulse { 50% { opacity: 0.7; } }
        .patbuf-input { width: 50px; background: #111; border: 1px solid #08a; color: #0af; padding: 0.2rem; font-family: inherit; font-size: 0.6rem; text-align: center; border-radius: 3px; }
        .patbuf-input:focus { outline: none; border-color: #0af; }
        .patbuf-toggle { padding: 0.15rem 0.4rem; font-family: inherit; font-size: 0.5rem; font-weight: bold; background: #111; color: #555; border: 1px solid #333; border-radius: 3px; cursor: pointer; text-transform: uppercase; }
        .patbuf-toggle:hover { border-color: #555; color: #888; }
        .patbuf-toggle.on { background: #08a; color: #000; border-color: #0af; }
        .patbuf-toggle.recording { background: #c00; color: #fff; border-color: #f00; box-shadow: 0 0 10px rgba(255, 0, 0, 0.4); animation: rec-btn-pulse 1s infinite; }
        @keyframes rec-btn-pulse { 0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.4); } 50% { box-shadow: 0 0 18px rgba(255, 0, 0, 0.7); } }
        .patbuf-status { font-size: 0.5rem; color: #08a; }
        .patbuf-graphs { display: flex; gap: 0.4rem; margin-top: 0.3rem; }
        .patbuf-graph-panel { flex: 1; }
        .patbuf-graph-label { font-size: 0.5rem; color: #666; margin-bottom: 0.15rem; display: flex; justify-content: space-between; align-items: center; }
        .patbuf-graph-label.tx-label { color: #0a0; }
        .patbuf-graph-label.rx-label { color: #0aa; }
        .patbuf-graph-info { font-size: 0.45rem; color: #555; }
        .patbuf-canvas { width: 100%; height: 50px; border: 1px solid #333; background: #050505; display: block; }
        .patbuf-canvas.tx-canvas { border-color: #0a0; }
        .patbuf-canvas.rx-canvas { border-color: #0aa; }
        .patbuf-slider-row { display: flex; flex-direction: column; gap: 0.25rem; margin-top: 0.3rem; padding-top: 0.3rem; border-top: 1px solid #222; }
        .patbuf-slider-top { display: flex; align-items: center; gap: 0.3rem; }
        .patbuf-slider-top label { font-size: 0.55rem; color: #08a; min-width: 30px; }
        .patbuf-slider-val { font-size: 0.55rem; color: #0af; min-width: 80px; text-align: right; }
        .patbuf-nav-btn { width: 22px; height: 18px; font-family: inherit; font-size: 0.6rem; font-weight: bold; background: #111; color: #0af; border: 1px solid #08a; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .patbuf-nav-btn:hover { background: #08a; color: #000; }
        .patbuf-nav-btn:disabled { border-color: #333; color: #333; cursor: not-allowed; }
        .patbuf-nav-btn:disabled:hover { background: #111; }
        .patbuf-timeline-container { position: relative; height: 24px; margin: 0.2rem 0; }
        .patbuf-timeline-canvas { width: 100%; height: 24px; border: 1px solid #08a; background: #0a0a0a; display: block; cursor: crosshair; }
        .patbuf-timeline-slider { position: absolute; top: 0; left: 0; right: 0; bottom: 0; -webkit-appearance: none; background: transparent; cursor: pointer; margin: 0; }
        .patbuf-timeline-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #aaa; cursor: ew-resize; border: none; border-radius: 50%; box-shadow: 0 0 3px rgba(0,0,0,0.6); }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Signal Test v24</h1>
        
        <!-- Transmit Section -->
        <div class="section tx">
            <div class="section-title">â–² Transmit</div>
            <div class="row">
                <label>Base</label>
                <input type="range" id="tx-slider" min="20" max="30000" step="10" value="18000">
                <input type="number" id="tx-input" value="18000" min="1" max="30000" step="1" style="width:60px;">
                <span class="hz">Hz</span>
            </div>
            <div class="row">
                <label>Step</label>
                <input type="number" id="tx-step" value="50" min="1" max="500" step="1" style="width:50px;">
                <span class="hz">Hz</span>
                <span class="range-display" id="tx-range-display"></span>
            </div>
            <div class="row">
                <label>Tol Â±</label>
                <input type="number" id="tx-tolerance" value="4" min="1" max="100" step="1" style="width:40px;">
                <span class="hz">Hz per bit</span>
            </div>
            <div class="binary-row">
                <span class="binary-label">Binary</span>
                <div class="toggle-group" id="tx-toggles"></div>
                <span class="binary-string" id="tx-binary">00000000</span>
                <span class="ascii-char" id="tx-ascii">(NUL)</span>
            </div>
        </div>
        
        <!-- Receive Section -->
        <div class="section rx">
            <div class="section-title">â–¼ Receive</div>
            <div class="row">
                <label>Base</label>
                <input type="range" id="rx-slider" min="20" max="30000" step="10" value="18000">
                <input type="number" id="rx-input" value="18000" min="1" max="30000" step="1" style="width:60px;">
                <span class="hz">Hz</span>
            </div>
            <div class="row">
                <label>Step</label>
                <input type="number" id="rx-step" value="50" min="1" max="500" step="1" style="width:50px;">
                <span class="hz">Hz</span>
                <span class="range-display" id="rx-range-display"></span>
            </div>
            <div class="row">
                <label>Tol Â±</label>
                <input type="number" id="rx-tolerance" value="4" min="1" max="100" step="1" style="width:40px;">
                <span class="hz">Hz per bit</span>
            </div>
            <div class="row">
                <label>Threshold</label>
                <input type="number" id="rx-thresh" value="40" min="5" max="200" step="5" style="width:45px;">
                <span class="hz">power</span>
            </div>
            <div class="binary-row">
                <span class="binary-label">Expect</span>
                <div class="toggle-group" id="rx-toggles"></div>
                <span class="binary-string" id="rx-binary">00000000</span>
                <span class="ascii-char" id="rx-ascii">(NUL)</span>
            </div>
        </div>
        
        <!-- De-noise Section -->
        <div class="section denoise">
            <div class="section-title">
                <span>ðŸ”‡ De-noise</span>
                <button class="denoise-toggle on" id="denoise-enabled" onclick="toggleDenoiseEnabled()">ON</button>
            </div>
            <div class="denoise-controls">
                <button class="denoise-btn" id="btn-listen" onclick="captureNoiseProfile()" disabled>LISTEN</button>
                <input type="number" id="denoise-duration" class="denoise-input" value="1000" min="100" max="10000" step="100">
                <span class="hz">ms</span>
                <span class="range-display" id="denoise-status">Ready</span>
            </div>
            <div class="denoise-master">
                <label>Master</label>
                <input type="range" id="denoise-master-slider" min="0" max="100" value="100">
                <span class="master-val" id="denoise-master-val">100%</span>
            </div>
            <div class="noise-profiles" id="noise-profiles">
                <div class="no-profiles">No noise profiles captured</div>
            </div>
        </div>
        
        <!-- Pattern Buffer Section -->
        <div class="section patbuf">
            <div class="section-title">
                <span>ðŸ“Š Pattern Buffers</span>
                <button class="patbuf-toggle on" id="patbuf-enabled" onclick="togglePatBufEnabled()">ON</button>
            </div>
            <div class="patbuf-controls">
                <label style="min-width:30px; color:#08a; font-size:0.55rem;">Rate</label>
                <input type="number" id="patbuf-rate" class="patbuf-input" value="1" min="1" max="100" style="width:40px;">
                <span class="hz">ms</span>
                <label style="min-width:35px; color:#08a; font-size:0.55rem;">Length</label>
                <input type="number" id="patbuf-length" class="patbuf-input" value="30000" min="100" max="99999" style="width:65px;">
                <span class="hz">ms</span>
                <button class="patbuf-toggle" id="patbuf-recording" onclick="togglePatBufRecording()">STOPPED</button>
                <button class="patbuf-btn" id="btn-snapshot" onclick="takeSnapshot()" disabled>SNAPSHOT</button>
            </div>
            <div class="row" style="margin-top:0.2rem;">
                <span class="patbuf-status" id="patbuf-status">Stopped</span>
                <span class="range-display" id="patbuf-info">â€”</span>
            </div>
            <div class="patbuf-graphs">
                <div class="patbuf-graph-panel">
                    <div class="patbuf-graph-label tx-label">
                        <span>TX Region</span>
                        <span class="patbuf-graph-info" id="patbuf-tx-info">â€”</span>
                    </div>
                    <canvas id="patbuf-tx-canvas" class="patbuf-canvas tx-canvas"></canvas>
                </div>
                <div class="patbuf-graph-panel">
                    <div class="patbuf-graph-label rx-label">
                        <span>RX Region</span>
                        <span class="patbuf-graph-info" id="patbuf-rx-info">â€”</span>
                    </div>
                    <canvas id="patbuf-rx-canvas" class="patbuf-canvas rx-canvas"></canvas>
                </div>
            </div>
            <div class="patbuf-slider-row" id="patbuf-slider-row" style="display:none;">
                <div class="patbuf-slider-top">
                    <label>Time</label>
                    <button class="patbuf-nav-btn" onclick="navSlider(-10)">Â«</button>
                    <button class="patbuf-nav-btn" onclick="navSlider(-1)">âˆ’</button>
                    <button class="patbuf-nav-btn" onclick="navSlider(1)">+</button>
                    <button class="patbuf-nav-btn" onclick="navSlider(10)">Â»</button>
                    <span class="patbuf-slider-val" id="patbuf-time-val">0ms / 30000ms</span>
                </div>
                <div class="patbuf-timeline-container">
                    <canvas id="patbuf-timeline-canvas" class="patbuf-timeline-canvas"></canvas>
                    <input type="range" id="patbuf-time-slider" class="patbuf-timeline-slider" min="0" max="29999" value="0">
                </div>
            </div>
        </div>
        
        <!-- Air & Pulse Controls -->
        <div class="air-toggle">
            <button class="air-btn" id="btn-air" onclick="toggleAir()">OFF AIR</button>
            <div class="pulse-group">
                <button class="pulse-btn" id="btn-pulse" onclick="manualPulse()" disabled>PULSE</button>
                <input type="number" id="pulse-duration" class="pulse-input" value="350" min="5" max="5000" step="5">
                <span class="pulse-label">ms</span>
                <button class="pulse-expander" id="pulse-expander" onclick="toggleAdvPulse()">â€º</button>
            </div>
        </div>
        
        <!-- Advanced Pulse Panel -->
        <div class="adv-pulse" id="adv-pulse">
            <div class="adv-pulse-title">â–¼ Sequence Pulse</div>
            <div class="adv-pulse-row">
                <label>Pattern</label>
                <input type="text" id="seq-pattern" placeholder="00000001, 00000010, 00000100" value="00000001, 00000010, 00000100">
            </div>
            <div class="adv-pulse-row">
                <label>Gap</label>
                <input type="number" id="seq-gap" value="100" min="0" max="5000" step="10">
                <span class="hz">ms</span>
                <label style="min-width:50px;">Repeats</label>
                <input type="number" id="seq-repeats" value="1" min="0" max="9999" step="1">
                <span class="hz">(0=âˆž)</span>
            </div>
            <div class="adv-pulse-row">
                <button class="adv-pulse-btn" id="btn-seq" onclick="toggleSequence()">START</button>
                <span class="adv-pulse-status" id="seq-status">Idle</span>
            </div>
        </div>
        
        <!-- Spectrum Graph -->
        <div class="graph-section">
            <div class="graph-header">
                <span class="graph-title">Spectrum</span>
                <div class="graph-controls">
                    <button class="zoom-toggle" id="zoom-tx" onclick="toggleZoomTx()">Tx</button>
                    <button class="zoom-toggle" id="zoom-rx" onclick="toggleZoomRx()">Rx</button>
                    <span class="zoom-sep">â”‚</span>
                    <button class="zoom-btn" onclick="zoomGraph(-1)">âˆ’</button>
                    <input type="number" id="hz-min" class="zoom-input" value="0" min="0" max="30000" step="100">
                    <span class="zoom-sep">â€“</span>
                    <input type="number" id="hz-max" class="zoom-input" value="4000" min="0" max="30000" step="100">
                    <span class="zoom-sep">Hz</span>
                    <button class="zoom-btn" onclick="zoomGraph(1)">+</button>
                    <span class="zoom-sep">â”‚</span>
                    <input type="number" id="pwr-min" class="zoom-input" value="0" min="0" max="255" step="5">
                    <span class="zoom-sep">â€“</span>
                    <input type="number" id="pwr-max" class="zoom-input" value="255" min="0" max="255" step="5">
                </div>
            </div>
            <div class="graph-container">
                <canvas id="graph"></canvas>
            </div>
        </div>
        
        <!-- Main Buttons -->
        <div class="button-row">
            <button class="main-btn btn-init" id="btn-init" onclick="init()">âš¡ INIT</button>
            <button class="main-btn btn-reset" onclick="resetAll()">â†»</button>
        </div>
    </div>

    <script>
        // ============================================================
        // CONSTANTS
        // ============================================================
        const FFT_SIZE = 8192;
        const NUM_BITS = 8;
        const ZOOM_LEVELS = [500, 1000, 2000, 4000, 8000, 12000, 20000, 30000];
        
        // ============================================================
        // STATE VARIABLES
        // ============================================================
        
        // Audio system
        let audioCtx, analyser, micStream, frequencyData;
        let oscillators = [], gainNodes = [];
        let isInit = false, isSending = false, isOnAir = false;
        
        // Transmit settings
        let txBaseFreq = 18000, txStep = 50, txTolerance = 4;
        let txToggles = [0,0,0,0,0,0,0,0];
        let txState = { active: false, pattern: '00000000' };
        
        // Receive settings
        let rxBaseFreq = 18000, rxStep = 50, rxTolerance = 4, rxThreshold = 40;
        let rxToggles = [0,0,0,0,0,0,0,0];
        
        // Pulse settings
        let pulseDuration = 350;
        let advPulseOpen = false;
        let seqRunning = false, seqInterval = null, seqIndex = 0, seqRepeatCount = 0;
        
        // Graph settings
        let zoomIndex = 3;
        let hzMin = 0, hzMax = 4000, pwrMin = 0, pwrMax = 255;
        let zoomTxOn = false, zoomRxOn = false;
        
        // De-noise system
        let noiseProfiles = [];
        let noiseProfileIdCounter = 0;
        let denoiseEnabled = true;
        let denoiseMasterLevel = 1.0;
        let isCapturingNoise = false;
        
        // Pattern buffer system
        let patBufEnabled = true;
        let patBufRecording = false;
        let patBufRate = 1;
        let patBufLength = 30000;
        let patBufInterval = null;
        let patBufWriteIndex = 0;
        let patBufSampleCount = 0;
        let txPatternBuffer = null, rxPatternBuffer = null;
        let txBufBinStart = 0, txBufBinEnd = 0, txBufBinCount = 0;
        let rxBufBinStart = 0, rxBufBinEnd = 0, rxBufBinCount = 0;
        
        // Snapshot data
        let snapshotData = null;
        let snapshotSliderPos = 0;
        let timelineOverlays = [];
        
        // Canvas references
        let graphCanvas, graphCtx;
        let patBufTxCanvas, patBufTxCtx;
        let patBufRxCanvas, patBufRxCtx;
        let timelineCanvas, timelineCtx;
        
        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================
        
        const $ = id => document.getElementById(id);
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const togglesToString = t => t.map(x => x ? '1' : '0').join('');
        const stringToToggles = s => s.split('').map(c => c === '1' ? 1 : 0);
        const getAllFreqs = (base, step) => Array.from({length: NUM_BITS}, (_, i) => base + i * step);
        const binaryToAscii = b => parseInt(b, 2);
        
        const ctrlChars = {0:'NUL',1:'SOH',2:'STX',3:'ETX',4:'EOT',5:'ENQ',6:'ACK',7:'BEL',8:'BS',9:'TAB',10:'LF',11:'VT',12:'FF',13:'CR',14:'SO',15:'SI',16:'DLE',17:'DC1',18:'DC2',19:'DC3',20:'DC4',21:'NAK',22:'SYN',23:'ETB',24:'CAN',25:'EM',26:'SUB',27:'ESC',28:'FS',29:'GS',30:'RS',31:'US',32:'SPC',127:'DEL'};
        const getAsciiDisplay = c => ctrlChars[c] !== undefined ? `(${ctrlChars[c]})` : (c >= 33 && c <= 126) ? `'${String.fromCharCode(c)}'` : `(x${c.toString(16).toUpperCase()})`;
        
        function isValidBinary(s) { return /^[01]{8}$/.test(s); }
        
        // ============================================================
        // DE-NOISE SYSTEM
        // ============================================================
        
        function toggleDenoiseEnabled() {
            denoiseEnabled = !denoiseEnabled;
            const btn = $('denoise-enabled');
            btn.classList.toggle('on', denoiseEnabled);
            btn.textContent = denoiseEnabled ? 'ON' : 'OFF';
        }
        
        function updateDenoiseMaster() {
            denoiseMasterLevel = parseInt($('denoise-master-slider').value) / 100;
            $('denoise-master-val').textContent = Math.round(denoiseMasterLevel * 100) + '%';
        }
        
        async function captureNoiseProfile() {
            if (!isInit || isCapturingNoise) return;
            const duration = parseInt($('denoise-duration').value) || 1000;
            const btn = $('btn-listen');
            isCapturingNoise = true;
            btn.classList.add('listening');
            btn.textContent = 'LISTENING...';
            $('denoise-status').textContent = 'Capturing...';
            
            const sampleCount = Math.ceil(duration / 50);
            const sampleInterval = duration / sampleCount;
            const samples = [];
            const binCount = analyser.frequencyBinCount;
            
            for (let i = 0; i < sampleCount; i++) {
                const sampleData = new Uint8Array(binCount);
                analyser.getByteFrequencyData(sampleData);
                samples.push(sampleData);
                await new Promise(r => setTimeout(r, sampleInterval));
            }
            
            const avgData = new Float32Array(binCount);
            for (let bin = 0; bin < binCount; bin++) {
                let sum = 0;
                for (const sample of samples) sum += sample[bin];
                avgData[bin] = sum / samples.length;
            }
            
            const profile = {
                id: ++noiseProfileIdCounter,
                name: `Profile ${noiseProfileIdCounter}`,
                data: avgData,
                amount: 1.0,
                timestamp: Date.now(),
                duration,
                samples: samples.length
            };
            noiseProfiles.push(profile);
            renderNoiseProfiles();
            
            isCapturingNoise = false;
            btn.classList.remove('listening');
            btn.textContent = 'LISTEN';
            $('denoise-status').textContent = `Profile #${profile.id} added`;
        }
        
        function deleteNoiseProfile(id) {
            noiseProfiles = noiseProfiles.filter(p => p.id !== id);
            renderNoiseProfiles();
        }
        
        function updateNoiseProfileName(id, name) {
            const profile = noiseProfiles.find(p => p.id === id);
            if (profile) profile.name = name;
        }
        
        function updateNoiseProfileAmount(id, value) {
            const profile = noiseProfiles.find(p => p.id === id);
            if (profile) {
                profile.amount = value;
                const valSpan = document.querySelector(`#noise-profile-${id} .slider-val`);
                if (valSpan) valSpan.textContent = Math.round(value * 100) + '%';
            }
        }
        
        function renderNoiseProfiles() {
            const container = $('noise-profiles');
            if (noiseProfiles.length === 0) {
                container.innerHTML = '<div class="no-profiles">No noise profiles captured</div>';
                return;
            }
            container.innerHTML = '';
            for (const profile of noiseProfiles) {
                const el = document.createElement('div');
                el.className = 'noise-profile';
                el.id = `noise-profile-${profile.id}`;
                
                const canvas = document.createElement('canvas');
                canvas.className = 'noise-profile-canvas';
                canvas.width = 120; canvas.height = 48;
                drawNoiseProfileMini(canvas, profile.data);
                
                const timeStr = new Date(profile.timestamp).toLocaleTimeString('en-US', {hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'});
                el.innerHTML = `
                    <div class="noise-profile-info">
                        <div class="noise-profile-name">
                            <input type="text" value="${profile.name}" onchange="updateNoiseProfileName(${profile.id}, this.value)" onclick="this.select()">
                        </div>
                        <div class="noise-profile-meta">${timeStr} Â· ${profile.duration}ms</div>
                        <div class="noise-profile-slider">
                            <input type="range" min="0" max="100" value="${Math.round(profile.amount * 100)}" oninput="updateNoiseProfileAmount(${profile.id}, this.value / 100)">
                            <span class="slider-val">${Math.round(profile.amount * 100)}%</span>
                        </div>
                    </div>
                    <button class="noise-profile-del" onclick="deleteNoiseProfile(${profile.id})">Ã—</button>`;
                el.insertBefore(canvas, el.firstChild);
                container.appendChild(el);
            }
        }
        
        function drawNoiseProfileMini(canvas, data) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = (w / 2) + 'px'; canvas.style.height = (h / 2) + 'px';
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, w, h);
            if (!audioCtx || !data) return;
            
            const binW = audioCtx.sampleRate / FFT_SIZE;
            const displayHz = 8000;
            const binsToShow = Math.min(data.length, Math.ceil(displayHz / binW));
            let maxVal = 1;
            for (let i = 0; i < binsToShow; i++) if (data[i] > maxVal) maxVal = data[i];
            
            const barWidth = w / binsToShow;
            ctx.fillStyle = '#a80';
            for (let i = 0; i < binsToShow; i++) {
                const barH = (data[i] / maxVal) * h * 0.9;
                ctx.fillRect(i * barWidth, h - barH, Math.max(barWidth - 0.5, 0.5), barH);
            }
            ctx.strokeStyle = '#444'; ctx.strokeRect(0, 0, w, h);
        }
        
        function applyDenoise(rawData) {
            if (!denoiseEnabled || noiseProfiles.length === 0 || denoiseMasterLevel === 0) return rawData;
            const result = new Uint8Array(rawData.length);
            for (let i = 0; i < rawData.length; i++) {
                let totalNoise = 0;
                for (const profile of noiseProfiles) totalNoise += (profile.data[i] || 0) * profile.amount;
                totalNoise *= denoiseMasterLevel;
                result[i] = Math.max(0, rawData[i] - totalNoise);
            }
            return result;
        }
        
        // ============================================================
        // PATTERN BUFFER SYSTEM
        // ============================================================
        
        function togglePatBufEnabled() {
            patBufEnabled = !patBufEnabled;
            const btn = $('patbuf-enabled');
            btn.classList.toggle('on', patBufEnabled);
            btn.textContent = patBufEnabled ? 'ON' : 'OFF';
            if (patBufEnabled && isInit) {
                initPatternBuffers();
            } else {
                stopPatternBufferCapture();
                patBufRecording = false;
                updateRecordingButton();
            }
        }
        
        function togglePatBufRecording() {
            if (!patBufEnabled || !isInit) return;
            patBufRecording = !patBufRecording;
            updateRecordingButton();
            patBufRecording ? startPatternBufferCapture() : stopPatternBufferCapture();
        }
        
        function updateRecordingButton() {
            const btn = $('patbuf-recording');
            btn.classList.remove('on', 'recording');
            if (patBufRecording) {
                btn.classList.add('recording');
                btn.textContent = 'RECORDING';
            } else {
                btn.textContent = 'STOPPED';
            }
        }
        
        function getPatBufBinRange(baseFreq, step) {
            const binW = audioCtx.sampleRate / FFT_SIZE;
            const lowHz = baseFreq - step;
            const highHz = baseFreq + 7 * step + step;
            const startBin = Math.max(0, Math.floor(lowHz / binW));
            const endBin = Math.min(analyser.frequencyBinCount - 1, Math.ceil(highHz / binW));
            return { startBin, endBin, binCount: endBin - startBin + 1, lowHz, highHz };
        }
        
        function initPatternBuffers() {
            if (!audioCtx || !analyser) return;
            patBufRate = clamp(parseInt($('patbuf-rate').value) || 1, 1, 100);
            patBufLength = clamp(parseInt($('patbuf-length').value) || 30000, 100, 99999);
            patBufSampleCount = Math.ceil(patBufLength / patBufRate);
            
            const txRange = getPatBufBinRange(txBaseFreq, txStep);
            const rxRange = getPatBufBinRange(rxBaseFreq, rxStep);
            txBufBinStart = txRange.startBin; txBufBinEnd = txRange.endBin; txBufBinCount = txRange.binCount;
            rxBufBinStart = rxRange.startBin; rxBufBinEnd = rxRange.endBin; rxBufBinCount = rxRange.binCount;
            
            txPatternBuffer = new Uint8Array(patBufSampleCount * txBufBinCount);
            rxPatternBuffer = new Uint8Array(patBufSampleCount * rxBufBinCount);
            patBufWriteIndex = 0;
            
            const txKb = (txPatternBuffer.length / 1024).toFixed(1);
            const rxKb = (rxPatternBuffer.length / 1024).toFixed(1);
            $('patbuf-info').textContent = `TX:${txBufBinCount}Ã—${patBufSampleCount}=${txKb}KB | RX:${rxBufBinCount}Ã—${patBufSampleCount}=${rxKb}KB`;
            $('patbuf-tx-info').textContent = `${txRange.lowHz}-${txRange.highHz}Hz (${txBufBinCount} bins)`;
            $('patbuf-rx-info').textContent = `${rxRange.lowHz}-${rxRange.highHz}Hz (${rxBufBinCount} bins)`;
        }
        
        function startPatternBufferCapture() {
            if (patBufInterval) clearInterval(patBufInterval);
            if (!patBufEnabled || !patBufRecording || !isInit) return;
            $('patbuf-status').textContent = 'Recording';
            $('btn-snapshot').classList.add('recording');
            
            patBufInterval = setInterval(() => {
                if (!analyser || !txPatternBuffer || !rxPatternBuffer) return;
                analyser.getByteFrequencyData(frequencyData);
                const data = applyDenoise(frequencyData);
                
                const txOffset = patBufWriteIndex * txBufBinCount;
                for (let i = 0; i < txBufBinCount; i++) txPatternBuffer[txOffset + i] = data[txBufBinStart + i] || 0;
                
                const rxOffset = patBufWriteIndex * rxBufBinCount;
                for (let i = 0; i < rxBufBinCount; i++) rxPatternBuffer[rxOffset + i] = data[rxBufBinStart + i] || 0;
                
                patBufWriteIndex = (patBufWriteIndex + 1) % patBufSampleCount;
            }, patBufRate);
        }
        
        function stopPatternBufferCapture() {
            if (patBufInterval) { clearInterval(patBufInterval); patBufInterval = null; }
            $('patbuf-status').textContent = 'Stopped';
            $('btn-snapshot').classList.remove('recording');
        }
        
        function takeSnapshot() {
            if (!txPatternBuffer || !rxPatternBuffer) return;
            
            const txData = new Uint8Array(patBufSampleCount * txBufBinCount);
            const rxData = new Uint8Array(patBufSampleCount * rxBufBinCount);
            
            for (let t = 0; t < patBufSampleCount; t++) {
                const srcIdx = (patBufWriteIndex + t) % patBufSampleCount;
                const txSrcOffset = srcIdx * txBufBinCount, txDstOffset = t * txBufBinCount;
                for (let b = 0; b < txBufBinCount; b++) txData[txDstOffset + b] = txPatternBuffer[txSrcOffset + b];
                const rxSrcOffset = srcIdx * rxBufBinCount, rxDstOffset = t * rxBufBinCount;
                for (let b = 0; b < rxBufBinCount; b++) rxData[rxDstOffset + b] = rxPatternBuffer[rxSrcOffset + b];
            }
            
            snapshotData = {
                txData, rxData,
                txBinCount: txBufBinCount, rxBinCount: rxBufBinCount,
                txBinStart: txBufBinStart, rxBinStart: rxBufBinStart,
                sampleCount: patBufSampleCount, rate: patBufRate, length: patBufLength,
                timestamp: Date.now(), txBaseFreq, txStep, rxBaseFreq, rxStep,
                txThresholdHits: computeThresholdCrossings(txData, txBufBinCount, patBufSampleCount, txBaseFreq, txStep),
                rxThresholdHits: computeThresholdCrossings(rxData, rxBufBinCount, patBufSampleCount, rxBaseFreq, rxStep)
            };
            
            snapshotSliderPos = patBufSampleCount - 1;
            const slider = $('patbuf-time-slider');
            slider.max = patBufSampleCount - 1;
            slider.value = snapshotSliderPos;
            $('patbuf-slider-row').style.display = 'flex';
            
            setupTimelineCanvas();
            updateSnapshotTimeDisplay();
            drawSnapshotGraphs();
            drawTimeline();
        }
        
        function computeThresholdCrossings(data, binCount, sampleCount, baseFreq, step) {
            const hits = new Uint8Array(sampleCount);
            const binW = audioCtx.sampleRate / FFT_SIZE;
            const lowHz = baseFreq - step;
            
            for (let t = 0; t < sampleCount; t++) {
                const offset = t * binCount;
                let hitMask = 0;
                for (let bit = 0; bit < NUM_BITS; bit++) {
                    const bitFreq = baseFreq + bit * step;
                    const bitBinCenter = Math.round((bitFreq - lowHz) / binW);
                    const tolBins = Math.ceil(rxTolerance / binW);
                    let maxPwr = 0;
                    for (let db = -tolBins; db <= tolBins; db++) {
                        const checkBin = bitBinCenter + db;
                        if (checkBin >= 0 && checkBin < binCount) {
                            const pwr = data[offset + checkBin] || 0;
                            if (pwr > maxPwr) maxPwr = pwr;
                        }
                    }
                    if (maxPwr >= rxThreshold) hitMask |= (1 << bit);
                }
                hits[t] = hitMask;
            }
            return hits;
        }
        
        function updateSnapshotTimeDisplay() {
            const timeMs = snapshotSliderPos * snapshotData.rate;
            $('patbuf-time-val').textContent = `${timeMs}ms / ${snapshotData.length}ms`;
        }
        
        function navSlider(delta) {
            if (!snapshotData) return;
            snapshotSliderPos = clamp(snapshotSliderPos + delta, 0, snapshotData.sampleCount - 1);
            $('patbuf-time-slider').value = snapshotSliderPos;
            updateSnapshotTimeDisplay();
            drawSnapshotGraphs();
            drawTimeline();
        }
        
        function reinitPatternBuffersIfNeeded() {
            if (isInit && patBufEnabled) {
                const wasRecording = patBufRecording;
                stopPatternBufferCapture();
                initPatternBuffers();
                if (wasRecording) { patBufRecording = true; updateRecordingButton(); startPatternBufferCapture(); }
            }
        }
        
        // ============================================================
        // CANVAS SETUP & DRAWING
        // ============================================================
        
        function setupPatBufCanvases() {
            patBufTxCanvas = $('patbuf-tx-canvas');
            patBufRxCanvas = $('patbuf-rx-canvas');
            const setupCanvas = (canvas) => {
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                return ctx;
            };
            patBufTxCtx = setupCanvas(patBufTxCanvas);
            patBufRxCtx = setupCanvas(patBufRxCanvas);
        }
        
        function setupTimelineCanvas() {
            timelineCanvas = $('patbuf-timeline-canvas');
            const rect = timelineCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            timelineCanvas.width = rect.width * dpr;
            timelineCanvas.height = rect.height * dpr;
            timelineCtx = timelineCanvas.getContext('2d');
            timelineCtx.scale(dpr, dpr);
            
            let isDragging = false;
            const updateFromX = (clientX) => {
                if (!snapshotData) return;
                const canvasRect = timelineCanvas.getBoundingClientRect();
                const ratio = clamp((clientX - canvasRect.left) / canvasRect.width, 0, 1);
                snapshotSliderPos = clamp(Math.round(ratio * (snapshotData.sampleCount - 1)), 0, snapshotData.sampleCount - 1);
                $('patbuf-time-slider').value = snapshotSliderPos;
                updateSnapshotTimeDisplay();
                drawSnapshotGraphs();
                drawTimeline();
            };
            
            timelineCanvas.onmousedown = (e) => { isDragging = true; updateFromX(e.clientX); };
            document.addEventListener('mousemove', (e) => { if (isDragging) updateFromX(e.clientX); });
            document.addEventListener('mouseup', () => { isDragging = false; });
            timelineCanvas.ontouchstart = (e) => { isDragging = true; if (e.touches.length > 0) { updateFromX(e.touches[0].clientX); e.preventDefault(); } };
            document.addEventListener('touchmove', (e) => { if (isDragging && e.touches.length > 0) updateFromX(e.touches[0].clientX); });
            document.addEventListener('touchend', () => { isDragging = false; });
        }
        
        function drawTimeline() {
            if (!snapshotData || !timelineCtx) return;
            const dpr = window.devicePixelRatio || 1;
            const w = timelineCanvas.width / dpr, h = timelineCanvas.height / dpr;
            const halfH = h / 2;
            
            timelineCtx.fillStyle = '#0a0a0a';
            timelineCtx.fillRect(0, 0, w, h);
            timelineCtx.strokeStyle = '#333';
            timelineCtx.beginPath(); timelineCtx.moveTo(0, halfH); timelineCtx.lineTo(w, halfH); timelineCtx.stroke();
            
            const pixelsPerSample = w / snapshotData.sampleCount;
            
            for (let t = 0; t < snapshotData.sampleCount; t++) {
                if (snapshotData.txThresholdHits[t] > 0) {
                    timelineCtx.fillStyle = 'rgba(0, 100, 50, 0.8)';
                    timelineCtx.fillRect(t * pixelsPerSample, 0, Math.max(pixelsPerSample, 1), halfH - 1);
                }
                if (snapshotData.rxThresholdHits[t] > 0) {
                    timelineCtx.fillStyle = 'rgba(0, 80, 120, 0.8)';
                    timelineCtx.fillRect(t * pixelsPerSample, halfH + 1, Math.max(pixelsPerSample, 1), halfH - 1);
                }
            }
            
            for (const o of timelineOverlays) {
                const startX = (o.startMs / snapshotData.rate) * pixelsPerSample;
                const endX = (o.endMs / snapshotData.rate) * pixelsPerSample;
                timelineCtx.fillStyle = o.color;
                timelineCtx.globalAlpha = o.alpha || 0.5;
                if (o.layer === 'tx') timelineCtx.fillRect(startX, 0, endX - startX, halfH - 1);
                else if (o.layer === 'rx') timelineCtx.fillRect(startX, halfH + 1, endX - startX, halfH - 1);
                else timelineCtx.fillRect(startX, 0, endX - startX, h);
                timelineCtx.globalAlpha = 1;
            }
            
            const posX = snapshotSliderPos * pixelsPerSample;
            timelineCtx.save();
            timelineCtx.globalCompositeOperation = 'difference';
            timelineCtx.strokeStyle = '#fff'; timelineCtx.lineWidth = 2;
            timelineCtx.beginPath(); timelineCtx.moveTo(posX, 0); timelineCtx.lineTo(posX, h); timelineCtx.stroke();
            timelineCtx.restore();
            
            timelineCtx.font = '8px Courier New';
            timelineCtx.fillStyle = '#0a0'; timelineCtx.fillText('TX', 2, 10);
            timelineCtx.fillStyle = '#0aa'; timelineCtx.fillText('RX', 2, h - 3);
        }
        
        function drawSnapshotGraphs() {
            if (!snapshotData || !patBufTxCtx || !patBufRxCtx) return;
            const dpr = window.devicePixelRatio || 1;
            drawSnapshotGraph(patBufTxCtx, patBufTxCanvas.width / dpr, patBufTxCanvas.height / dpr, snapshotData.txData, snapshotData.txBinCount, snapshotSliderPos, '#0f0', '#0a0', snapshotData.txBaseFreq, snapshotData.txStep);
            drawSnapshotGraph(patBufRxCtx, patBufRxCanvas.width / dpr, patBufRxCanvas.height / dpr, snapshotData.rxData, snapshotData.rxBinCount, snapshotSliderPos, '#0ff', '#0aa', snapshotData.rxBaseFreq, snapshotData.rxStep);
        }
        
        function drawSnapshotGraph(ctx, w, h, data, binCount, timeIdx, colorBright, colorDim, baseFreq, step) {
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, w, h);
            if (!data || binCount === 0) { ctx.fillStyle = '#333'; ctx.font = '8px Courier New'; ctx.textAlign = 'center'; ctx.fillText('No data', w / 2, h / 2); return; }
            
            const offset = timeIdx * binCount;
            const barWidth = w / binCount;
            const binW = audioCtx.sampleRate / FFT_SIZE;
            const lowHz = baseFreq - step;
            
            for (let bit = 0; bit < NUM_BITS; bit++) {
                const binIdx = Math.round((baseFreq + bit * step - lowHz) / binW);
                if (binIdx >= 0 && binIdx < binCount) {
                    const x = binIdx * barWidth + barWidth / 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                    ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.font = '6px Courier New'; ctx.textAlign = 'center';
                    ctx.fillText(bit + 1, x, 8);
                }
            }
            
            for (let i = 0; i < binCount; i++) {
                const val = data[offset + i] || 0;
                const barH = (val / 255) * h * 0.9;
                const intensity = val / 255;
                ctx.fillStyle = intensity > 0.3 ? colorBright : colorDim;
                ctx.globalAlpha = 0.3 + intensity * 0.7;
                ctx.fillRect(i * barWidth, h - barH, Math.max(barWidth - 0.5, 1), barH);
            }
            ctx.globalAlpha = 1;
            
            const threshY = h - (rxThreshold / 255) * h * 0.9;
            ctx.strokeStyle = 'rgba(255,255,0,0.4)'; ctx.setLineDash([2, 2]);
            ctx.beginPath(); ctx.moveTo(0, threshY); ctx.lineTo(w, threshY); ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function setupGraph() {
            graphCanvas = $('graph');
            graphCtx = graphCanvas.getContext('2d');
            const rect = graphCanvas.getBoundingClientRect();
            graphCanvas.width = rect.width * devicePixelRatio;
            graphCanvas.height = rect.height * devicePixelRatio;
            graphCtx.scale(devicePixelRatio, devicePixelRatio);
        }
        
        function drawGraph() {
            if (!graphCtx) { requestAnimationFrame(drawGraph); return; }
            const w = graphCanvas.width / devicePixelRatio;
            const h = graphCanvas.height / devicePixelRatio;
            const hzRange = hzMax - hzMin, pwrRange = pwrMax - pwrMin;
            
            graphCtx.fillStyle = 'rgb(5, 5, 5)'; graphCtx.fillRect(0, 0, w, h);
            
            const hzToX = hz => ((hz - hzMin) / hzRange) * w;
            const pwrToY = pwr => h - ((clamp(pwr, pwrMin, pwrMax) - pwrMin) / pwrRange) * h;
            const txFreqs = getAllFreqs(txBaseFreq, txStep);
            const rxFreqs = getAllFreqs(rxBaseFreq, rxStep);
            
            // Draw TX frequency bands
            for (let i = 0; i < NUM_BITS; i++) {
                const freq = txFreqs[i];
                if (freq + txTolerance < hzMin || freq - txTolerance > hzMax) continue;
                const x1 = hzToX(freq - txTolerance), x2 = hzToX(freq + txTolerance);
                graphCtx.fillStyle = txToggles[i] ? 'rgba(0, 255, 0, 0.10)' : 'rgba(0, 255, 0, 0.03)';
                graphCtx.fillRect(x1, 0, Math.max(x2 - x1, 1), h);
                graphCtx.strokeStyle = txToggles[i] ? 'rgba(0, 255, 0, 0.4)' : 'rgba(0, 255, 0, 0.12)';
                graphCtx.beginPath(); graphCtx.moveTo(hzToX(freq), 0); graphCtx.lineTo(hzToX(freq), h); graphCtx.stroke();
            }
            
            // Draw RX frequency bands
            for (let i = 0; i < NUM_BITS; i++) {
                const freq = rxFreqs[i];
                if (freq + rxTolerance < hzMin || freq - rxTolerance > hzMax) continue;
                const x1 = hzToX(freq - rxTolerance), x2 = hzToX(freq + rxTolerance);
                graphCtx.fillStyle = rxToggles[i] ? 'rgba(0, 150, 255, 0.10)' : 'rgba(0, 150, 255, 0.03)';
                graphCtx.fillRect(x1, 0, Math.max(x2 - x1, 1), h);
                graphCtx.strokeStyle = rxToggles[i] ? 'rgba(0, 200, 255, 0.4)' : 'rgba(0, 150, 255, 0.12)';
                graphCtx.beginPath(); graphCtx.moveTo(hzToX(freq), 0); graphCtx.lineTo(hzToX(freq), h); graphCtx.stroke();
                graphCtx.fillStyle = rxToggles[i] ? 'rgba(0, 200, 255, 0.6)' : 'rgba(100, 100, 100, 0.3)';
                graphCtx.font = '7px Courier New';
                graphCtx.fillText(i + 1, hzToX(freq) - 2, 9);
            }
            
            // Draw live spectrum data
            if (isOnAir && analyser) {
                analyser.getByteFrequencyData(frequencyData);
                const displayData = applyDenoise(frequencyData);
                const binW = audioCtx.sampleRate / analyser.fftSize;
                const startBin = Math.max(0, Math.floor(hzMin / binW));
                const endBin = Math.min(displayData.length, Math.ceil(hzMax / binW));
                
                for (let i = startBin; i < endBin; i++) {
                    const freq = i * binW, pwr = displayData[i];
                    if (pwr < pwrMin) continue;
                    const x = hzToX(freq);
                    const barH = ((Math.min(pwr, pwrMax) - pwrMin) / pwrRange) * h;
                    const v = pwr / 255;
                    let inTx = isSending && stringToToggles(txState.pattern).some((t, j) => t && Math.abs(freq - txFreqs[j]) <= txTolerance);
                    let inRx = rxFreqs.some((f) => Math.abs(freq - f) <= rxTolerance);
                    graphCtx.fillStyle = inTx ? `rgba(0, 255, 0, ${0.4 + v * 0.6})` : inRx ? `rgba(0, 200, 255, ${0.3 + v * 0.7})` : `rgba(100, 100, 100, ${0.2 + v * 0.6})`;
                    graphCtx.fillRect(x, h - barH, Math.max(w / (endBin - startBin) - 1, 1), barH);
                }
            }
            
            // Draw threshold line
            if (rxThreshold >= pwrMin && rxThreshold <= pwrMax) {
                graphCtx.strokeStyle = 'rgba(255, 255, 0, 0.3)'; graphCtx.setLineDash([3, 3]);
                graphCtx.beginPath(); graphCtx.moveTo(0, pwrToY(rxThreshold)); graphCtx.lineTo(w, pwrToY(rxThreshold)); graphCtx.stroke();
                graphCtx.setLineDash([]);
            }
            
            // Draw Hz labels
            graphCtx.fillStyle = '#444'; graphCtx.font = '8px Courier New';
            const step = hzRange <= 500 ? 100 : hzRange <= 1000 ? 200 : hzRange <= 4000 ? 500 : hzRange <= 10000 ? 2000 : 5000;
            for (let f = Math.ceil(hzMin / step) * step; f <= hzMax; f += step) {
                graphCtx.fillText(f >= 1000 ? `${f/1000}k` : f, hzToX(f) - 8, h - 2);
            }
            
            requestAnimationFrame(drawGraph);
        }
        
        // ============================================================
        // GRAPH ZOOM CONTROLS
        // ============================================================
        
        function getTxRange() { return { min: txBaseFreq - txTolerance - txStep, max: txBaseFreq + 7 * txStep + txTolerance + txStep }; }
        function getRxRange() { return { min: rxBaseFreq - rxTolerance - rxStep, max: rxBaseFreq + 7 * rxStep + rxTolerance + rxStep }; }
        
        function applyZoomToggles() {
            if (!zoomTxOn && !zoomRxOn) return;
            let minHz = Infinity, maxHz = -Infinity;
            if (zoomTxOn) { const tx = getTxRange(); minHz = Math.min(minHz, tx.min); maxHz = Math.max(maxHz, tx.max); }
            if (zoomRxOn) { const rx = getRxRange(); minHz = Math.min(minHz, rx.min); maxHz = Math.max(maxHz, rx.max); }
            hzMin = Math.max(0, Math.floor(minHz)); hzMax = Math.ceil(maxHz);
            updateZoomInputs();
        }
        
        function toggleZoomTx() { zoomTxOn = !zoomTxOn; $('zoom-tx').classList.toggle('tx-on', zoomTxOn); applyZoomToggles(); }
        function toggleZoomRx() { zoomRxOn = !zoomRxOn; $('zoom-rx').classList.toggle('rx-on', zoomRxOn); applyZoomToggles(); }
        
        function zoomGraph(dir) {
            zoomTxOn = zoomRxOn = false;
            $('zoom-tx').classList.remove('tx-on'); $('zoom-rx').classList.remove('rx-on');
            zoomIndex = clamp(zoomIndex + dir, 0, ZOOM_LEVELS.length - 1);
            hzMax = ZOOM_LEVELS[zoomIndex]; hzMin = 0;
            updateZoomInputs();
        }
        
        function updateZoomInputs() { $('hz-min').value = hzMin; $('hz-max').value = hzMax; $('pwr-min').value = pwrMin; $('pwr-max').value = pwrMax; }
        
        function readZoomInputs() {
            zoomTxOn = zoomRxOn = false;
            $('zoom-tx').classList.remove('tx-on'); $('zoom-rx').classList.remove('rx-on');
            hzMin = clamp(parseInt($('hz-min').value) || 0, 0, 30000);
            hzMax = clamp(parseInt($('hz-max').value) || 4000, hzMin + 100, 30000);
            pwrMin = clamp(parseInt($('pwr-min').value) || 0, 0, 255);
            pwrMax = clamp(parseInt($('pwr-max').value) || 255, pwrMin + 10, 255);
            updateZoomInputs();
        }
        
        // ============================================================
        // TOGGLE & DISPLAY FUNCTIONS
        // ============================================================
        
        function createToggles(containerId, toggleArray, updateCallback) {
            const container = $(containerId);
            container.innerHTML = '';
            for (let i = 0; i < NUM_BITS; i++) {
                const btn = document.createElement('div');
                btn.className = 'bit-toggle' + (toggleArray[i] ? ' on' : '');
                btn.innerHTML = `<span class="bit-num">${i + 1}</span><span class="bit-val">${toggleArray[i]}</span>`;
                btn.onclick = () => {
                    toggleArray[i] = toggleArray[i] ? 0 : 1;
                    btn.classList.toggle('on', toggleArray[i]);
                    btn.querySelector('.bit-val').textContent = toggleArray[i];
                    updateCallback();
                };
                container.appendChild(btn);
            }
        }
        
        function updateTxDisplay() {
            const b = togglesToString(txToggles);
            $('tx-binary').textContent = b;
            $('tx-ascii').textContent = getAsciiDisplay(binaryToAscii(b));
            $('tx-range-display').textContent = `${txBaseFreq}â€“${txBaseFreq + 7*txStep} Hz`;
            if (zoomTxOn) applyZoomToggles();
        }
        
        function updateRxDisplay() {
            const b = togglesToString(rxToggles);
            $('rx-binary').textContent = b;
            $('rx-ascii').textContent = getAsciiDisplay(binaryToAscii(b));
            $('rx-range-display').textContent = `${rxBaseFreq}â€“${rxBaseFreq + 7*rxStep} Hz`;
            if (zoomRxOn) applyZoomToggles();
        }
        
        const updateTxBaseFreq = f => { txBaseFreq = clamp(Math.round(f), 1, 30000); $('tx-input').value = txBaseFreq; $('tx-slider').value = clamp(txBaseFreq, 20, 30000); updateTxDisplay(); reinitPatternBuffersIfNeeded(); };
        const updateRxBaseFreq = f => { rxBaseFreq = clamp(Math.round(f), 1, 30000); $('rx-input').value = rxBaseFreq; $('rx-slider').value = clamp(rxBaseFreq, 20, 30000); updateRxDisplay(); reinitPatternBuffersIfNeeded(); };
        
        // ============================================================
        // AIR & PULSE CONTROLS
        // ============================================================
        
        function toggleAir() {
            if (!isInit) return;
            isOnAir = !isOnAir;
            $('btn-air').classList.toggle('on', isOnAir);
            $('btn-air').textContent = isOnAir ? 'ON AIR' : 'OFF AIR';
        }
        
        function manualPulse() {
            if (!isInit || isSending) return;
            if (!isOnAir) toggleAir();
            sendPatternPulse(togglesToString(txToggles), pulseDuration);
        }
        
        async function sendPatternPulse(pattern, durMs) {
            return new Promise(resolve => {
                const toggles = stringToToggles(pattern);
                isSending = true;
                txState.active = true;
                txState.pattern = pattern;
                for (let i = 0; i < NUM_BITS; i++) {
                    oscillators[i].frequency.setValueAtTime(txBaseFreq + i * txStep, audioCtx.currentTime);
                    gainNodes[i].gain.setValueAtTime(toggles[i] ? 0.15 : 0, audioCtx.currentTime);
                }
                setTimeout(() => {
                    gainNodes.forEach(g => g.gain.setValueAtTime(0, audioCtx.currentTime));
                    setTimeout(() => { isSending = false; txState.active = false; resolve(); }, 50);
                }, durMs);
            });
        }
        
        // ============================================================
        // ADVANCED PULSE SEQUENCE
        // ============================================================
        
        function toggleAdvPulse() {
            advPulseOpen = !advPulseOpen;
            $('adv-pulse').classList.toggle('open', advPulseOpen);
            $('pulse-expander').textContent = advPulseOpen ? 'v' : 'â€º';
        }
        
        function parseSequencePatterns() {
            const raw = $('seq-pattern').value;
            const patterns = raw.split(',').map(s => s.trim()).filter(s => isValidBinary(s));
            return patterns;
        }
        
        function toggleSequence() {
            if (seqRunning) {
                stopSequence();
            } else {
                startSequence();
            }
        }
        
        function startSequence() {
            const patterns = parseSequencePatterns();
            if (patterns.length === 0) { $('seq-status').textContent = 'Invalid patterns!'; return; }
            
            const gap = clamp(parseInt($('seq-gap').value) || 100, 0, 5000);
            const repeats = clamp(parseInt($('seq-repeats').value) || 1, 0, 9999);
            const pulseMs = pulseDuration;
            
            seqRunning = true;
            seqIndex = 0;
            seqRepeatCount = 0;
            
            $('btn-seq').textContent = 'STOP';
            $('btn-seq').classList.add('running');
            $('seq-status').textContent = `Running... (${patterns.length} patterns)`;
            
            if (!isOnAir) toggleAir();
            
            const runStep = async () => {
                if (!seqRunning) return;
                
                const pattern = patterns[seqIndex];
                await sendPatternPulse(pattern, pulseMs);
                
                seqIndex++;
                if (seqIndex >= patterns.length) {
                    seqIndex = 0;
                    seqRepeatCount++;
                    if (repeats > 0 && seqRepeatCount >= repeats) {
                        stopSequence();
                        return;
                    }
                }
                
                $('seq-status').textContent = `Rep ${seqRepeatCount + 1}${repeats > 0 ? '/' + repeats : ''}, Pat ${seqIndex + 1}/${patterns.length}`;
                
                if (seqRunning) {
                    seqInterval = setTimeout(runStep, gap);
                }
            };
            
            runStep();
        }
        
        function stopSequence() {
            seqRunning = false;
            if (seqInterval) { clearTimeout(seqInterval); seqInterval = null; }
            $('btn-seq').textContent = 'START';
            $('btn-seq').classList.remove('running');
            $('seq-status').textContent = 'Stopped';
        }
        
        // ============================================================
        // INITIALIZATION & RESET
        // ============================================================
        
        async function init() {
            if (isInit) return;
            $('btn-init').disabled = true;
            
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                
                micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = 0.3;
                audioCtx.createMediaStreamSource(micStream).connect(analyser);
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                
                for (let i = 0; i < NUM_BITS; i++) {
                    const gain = audioCtx.createGain();
                    gain.gain.value = 0;
                    gain.connect(audioCtx.destination);
                    gainNodes.push(gain);
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = txBaseFreq + i * txStep;
                    osc.connect(gain);
                    osc.start();
                    oscillators.push(osc);
                }
                
                setupGraph();
                setupPatBufCanvases();
                requestAnimationFrame(drawGraph);
                if (patBufEnabled) initPatternBuffers();
                
                isInit = true;
                $('btn-init').style.display = 'none';
                $('btn-pulse').disabled = false;
                $('btn-listen').disabled = false;
                $('btn-snapshot').disabled = false;
                
            } catch (e) {
                $('btn-init').disabled = false;
                alert('Error: ' + e.message);
            }
        }
        
        function resetAll() {
            txState = { active: false, pattern: '00000000' };
            $('denoise-status').textContent = 'Ready';
            snapshotData = null;
            timelineOverlays = [];
            $('patbuf-slider-row').style.display = 'none';
            
            if (patBufTxCtx && patBufRxCtx) {
                const dpr = window.devicePixelRatio || 1;
                patBufTxCtx.fillStyle = '#050505';
                patBufTxCtx.fillRect(0, 0, patBufTxCanvas.width / dpr, patBufTxCanvas.height / dpr);
                patBufRxCtx.fillStyle = '#050505';
                patBufRxCtx.fillRect(0, 0, patBufRxCanvas.width / dpr, patBufRxCanvas.height / dpr);
            }
            
            stopPatternBufferCapture();
            patBufRecording = false;
            updateRecordingButton();
            stopSequence();
        }
        
        // ============================================================
        // EVENT HANDLERS
        // ============================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize toggles
            createToggles('tx-toggles', txToggles, updateTxDisplay);
            createToggles('rx-toggles', rxToggles, updateRxDisplay);
            updateTxBaseFreq(txBaseFreq);
            updateRxBaseFreq(rxBaseFreq);
            updateZoomInputs();
            
            // Setup canvases
            setupGraph();
            setupPatBufCanvases();
            requestAnimationFrame(drawGraph);
            renderNoiseProfiles();
            
            // Input handlers - TX
            $('tx-slider').oninput = () => updateTxBaseFreq(+$('tx-slider').value);
            $('tx-input').onchange = () => updateTxBaseFreq(+$('tx-input').value || 1);
            $('tx-step').onchange = () => { txStep = clamp(+$('tx-step').value || 50, 1, 500); updateTxDisplay(); reinitPatternBuffersIfNeeded(); };
            $('tx-tolerance').onchange = () => { txTolerance = clamp(+$('tx-tolerance').value || 4, 1, 100); updateTxDisplay(); };
            
            // Input handlers - RX
            $('rx-slider').oninput = () => updateRxBaseFreq(+$('rx-slider').value);
            $('rx-input').onchange = () => updateRxBaseFreq(+$('rx-input').value || 1);
            $('rx-step').onchange = () => { rxStep = clamp(+$('rx-step').value || 50, 1, 500); updateRxDisplay(); reinitPatternBuffersIfNeeded(); };
            $('rx-tolerance').onchange = () => { rxTolerance = clamp(+$('rx-tolerance').value || 4, 1, 100); updateRxDisplay(); };
            $('rx-thresh').onchange = () => { rxThreshold = clamp(+$('rx-thresh').value || 40, 5, 200); };
            
            // Input handlers - Pulse
            $('pulse-duration').onchange = () => { pulseDuration = clamp(+$('pulse-duration').value || 350, 5, 5000); };
            
            // Input handlers - De-noise
            $('denoise-master-slider').oninput = updateDenoiseMaster;
            
            // Input handlers - Pattern buffer
            $('patbuf-rate').onchange = function() { patBufRate = clamp(parseInt(this.value) || 1, 1, 100); this.value = patBufRate; reinitPatternBuffersIfNeeded(); };
            $('patbuf-length').onchange = function() { patBufLength = clamp(parseInt(this.value) || 30000, 100, 99999); this.value = patBufLength; reinitPatternBuffersIfNeeded(); };
            $('patbuf-time-slider').oninput = function() { if (!snapshotData) return; snapshotSliderPos = parseInt(this.value); updateSnapshotTimeDisplay(); drawSnapshotGraphs(); drawTimeline(); };
            
            // Input handlers - Graph zoom
            $('hz-min').onchange = $('hz-max').onchange = $('pwr-min').onchange = $('pwr-max').onchange = readZoomInputs;
        });
        
        window.addEventListener('resize', () => {
            if (graphCanvas) setupGraph();
            if (patBufTxCanvas) setupPatBufCanvases();
            if (snapshotData) { setupTimelineCanvas(); drawSnapshotGraphs(); drawTimeline(); }
        });
    </script>
</body>
</html>
